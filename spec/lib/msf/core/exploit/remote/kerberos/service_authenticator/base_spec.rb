# -*- coding:binary -*-
require 'spec_helper'

RSpec.describe Msf::Exploit::Remote::Kerberos::ServiceAuthenticator::Base do
  if ENV['REMOTE_DB']
    # https://github.com/rapid7/metasploit-framework/pull/9939/files#diff-08c7b840568ae1bf6ed26d4d4288e5e8c1b817f8622dec8fb38417c74be6765d
    before { skip('Awaiting cred port') }
  end

  let(:framework)  { instance_double(::Msf::Framework) }
  let(:mod) { instance_double(::Msf::Module) }
  let(:realm_string) { 'demo.local' }
  let(:username) { 'mock_user' }
  subject do
    described_class.new(
      realm: realm_string,
      hostname: 'mock_hostname',
      username: username,
      password: 'mock_password',
      host: '192.0.2.2',
      port: 88,
      timeout: 25,
      framework: framework,
      framework_module: mod
    )
  end

  describe "#validate_response!" do
    context 'when the response is a success' do
      let(:response) do
        "\xa1\x14\x30\x12\xa0\x03\x0a\x01\x00\xa1\x0b\x06\x09\x2a\x86\x48" \
        "\x82\xf7\x12\x01\x02\x02"
      end

      it 'returns true' do
        expect(subject.validate_response!(response)).to be true
      end
    end

    context 'when the response is accept-incomplete and contains a kerberos error' do
      let(:response) do
        "\xa1\x81\x89\x30\x81\x86\xa0\x03\x0a\x01\x01\xa1\x0b\x06\x09\x2a" \
        "\x86\x48\x82\xf7\x12\x01\x02\x02\xa2\x72\x04\x70\x60\x6e\x06\x09" \
        "\x2a\x86\x48\x86\xf7\x12\x01\x02\x02\x03\x00\x7e\x5f\x30\x5d\xa0" \
        "\x03\x02\x01\x05\xa1\x03\x02\x01\x1e\xa4\x11\x18\x0f\x32\x30\x32" \
        "\x32\x30\x36\x32\x39\x32\x33\x32\x32\x31\x31\x5a\xa5\x05\x02\x03" \
        "\x0e\x45\xd0\xa6\x03\x02\x01\x3c\xa9\x0c\x1b\x0a\x41\x44\x46\x33" \
        "\x2e\x4c\x4f\x43\x41\x4c\xaa\x11\x30\x0f\xa0\x03\x02\x01\x01\xa1" \
        "\x08\x30\x06\x1b\x04\x64\x63\x33\x24\xac\x11\x04\x0f\x30\x0d\xa1" \
        "\x03\x02\x01\x01\xa2\x06\x04\x04\x6d\x00\x00\xc0"
      end

      it 'raises a Kerberos exception' do
        expect { subject.validate_response!(response) }.to raise_error(::Rex::Proto::Kerberos::Model::Error::KerberosError, /Failed to negotiate/)
      end
    end
  end

  describe '#find_krbticket_core' do
    include_context 'Msf::DBManager'
    include_context 'Msf::Framework#threads cleaner', verify_cleanup_required: false

    let(:workspace) { framework.db.workspace }
    let(:mod) do
      double :module,
             workspace: workspace,
             mytask: nil
    end

    let(:service) { FactoryBot.create(:mdm_service, host: FactoryBot.create(:mdm_host, workspace: workspace)) }
    let(:origin) { FactoryBot.create(:metasploit_credential_origin_service, service: service) }
    let(:pub) { FactoryBot.create(:metasploit_credential_username, username: username) }
    let(:realm) do
      FactoryBot.create(
        :metasploit_credential_realm,
        key: Metasploit::Model::Realm::Key::ACTIVE_DIRECTORY_DOMAIN,
        value: realm_string
      )
    end
    let(:private) do
      FactoryBot.create(:metasploit_credential_krb_ticket, :with_tgt)
    end
    let!(:core) do
      FactoryBot.create(
        :metasploit_credential_core,
        origin: origin,
        private: private,
        public: pub,
        realm: realm,
        workspace: framework.db.workspace
      )
    end
    let(:search_opts) do
      {
        sname: private.sname
      }
    end

    def find_krbticket_core(search_opts)
      subject.send(:find_krbticket_core, search_opts)
    end

    context 'when there is no db' do
      it 'returns nil' do
        allow(subject).to receive(:active_db?).and_return(false)
        expect(find_krbticket_core(search_opts)).to be_nil
      end
    end

    context 'when there is a matching ticket' do
      let(:private) do
        FactoryBot.create(:metasploit_credential_krb_ticket, :with_tgt)
      end
      let(:search_opts) do
        {
          sname: private.sname
        }
      end

      it 'returns the matched core' do
        expect(find_krbticket_core(search_opts)).to eq core
      end
    end

    context 'when the ticket has expired' do
      let(:private) do
        FactoryBot.create(:metasploit_credential_krb_ticket, :with_expired_tgt)
      end
      let(:search_opts) do
        {
          sname: private.sname
        }
      end

      it 'returns nil' do
        expect(find_krbticket_core(search_opts)).to be_nil
      end
    end

    context 'when the private username is in a different case' do
      let(:private) do
        FactoryBot.create(:metasploit_credential_krb_ticket, :with_tgs)
      end
      let(:pub) { FactoryBot.create(:metasploit_credential_username, username: username.upcase) }
      let(:search_opts) do
        {
          sname: private.sname
        }
      end

      it 'returns nil' do
        expect(find_krbticket_core(search_opts)).to eq(core)
      end
    end
  end
end
